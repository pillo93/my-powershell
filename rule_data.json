[
  {
    "rule": {
      "rule_title": "Prefer ScopedValue over ThreadLocal for immutable data transmission",
      "rule_idea": "When ThreadLocal is used only for one-way transmission of immutable data from caller to callees without mutation, it should be replaced with ScopedValue. ScopedValue provides better performance, bounded lifetime, clearer semantics, and eliminates the risk of memory leaks that can occur when ThreadLocal.remove() is forgotten. This pattern is particularly beneficial when sharing context data like user principals, request IDs, or configuration values down the call stack. Replace ThreadLocal.set() calls with ScopedValue.where().run() to establish bounded scoped bindings instead of unbounded thread-local assignments.",
      "code_examples": [
        {
          "non_compliant": "private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();\n\nvoid serve() {\n    CONTEXT.set(\"value\");\n    processRequest();\n    CONTEXT.remove(); // Easy to forget, potential memory leak\n}",
          "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();\n\nvoid serve() {\n    ScopedValue.where(CONTEXT, \"value\").run(() -> processRequest());\n}"
        },
        {
          "non_compliant": "class RequestProcessor {\n    private static final ThreadLocal<String> REQUEST_ID = new ThreadLocal<>();\n    \n    public void handleRequest(String requestId) {\n        REQUEST_ID.set(requestId); // Immutable data but using mutable ThreadLocal\n        processRequest();\n        REQUEST_ID.remove();\n    }\n}",
          "compliant": "class RequestProcessor {\n    private static final ScopedValue<String> REQUEST_ID = ScopedValue.newInstance();\n    \n    public void handleRequest(String requestId) {\n        ScopedValue.where(REQUEST_ID, requestId)\n                   .run(this::processRequest);\n    }\n}"
        },
        {
          "non_compliant": "class Server {\n    final static ThreadLocal<Principal> PRINCIPAL = new ThreadLocal<>();\n    \n    void serve(Request request, Response response) {\n        var principal = new Principal(request.isAdmin() ? ADMIN : GUEST);\n        PRINCIPAL.set(principal);\n        Application.handle(request, response);\n        // Missing remove() call - potential memory leak\n    }\n}",
          "compliant": "class Server {\n    final static ScopedValue<Principal> PRINCIPAL = ScopedValue.newInstance();\n    \n    void serve(Request request, Response response) {\n        var principal = new Principal(request.isAdmin() ? ADMIN : GUEST);\n        ScopedValue.where(PRINCIPAL, principal)\n                   .run(() -> Application.handle(request, response));\n    }\n}"
        }
      ],
      "sources": [
        {
          "cluster_description": "All three rules address the migration from ThreadLocal to ScopedValue for one-way immutable data transmission, emphasizing the benefits of bounded lifetime, better performance, clearer semantics, and elimination of memory leak risks.",
          "original_ideas": [
            {
              "rule_title": "Prefer ScopedValue over ThreadLocal for one-way immutable data transmission",
              "rule_idea": "When ThreadLocal is used only for one-way transmission of immutable data from caller to callees without mutation, it should be replaced with ScopedValue. ScopedValue provides better performance, bounded lifetime, clearer semantics, and eliminates the risk of memory leaks that can occur when ThreadLocal.remove() is forgotten. This pattern is particularly beneficial when sharing context data like user principals, request IDs, or configuration values down the call stack.",
              "code_examples": [
                {
                  "non_compliant": "private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();\n\nvoid serve() {\n    CONTEXT.set(\"value\");\n    processRequest();\n    CONTEXT.remove(); // Easy to forget, potential memory leak\n}",
                  "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();\n\nvoid serve() {\n    ScopedValue.where(CONTEXT, \"value\").run(() -> processRequest());\n}"
                },
                {
                  "non_compliant": "class Server {\n    final static ThreadLocal<Principal> PRINCIPAL = new ThreadLocal<>();\n    \n    void serve(Request request, Response response) {\n        var principal = new Principal(request.isAdmin() ? ADMIN : GUEST);\n        PRINCIPAL.set(principal);\n        Application.handle(request, response);\n        // Missing remove() call - potential memory leak\n    }\n}",
                  "compliant": "class Server {\n    final static ScopedValue<Principal> PRINCIPAL = ScopedValue.newInstance();\n    \n    void serve(Request request, Response response) {\n        var principal = new Principal(request.isAdmin() ? ADMIN : GUEST);\n        ScopedValue.where(PRINCIPAL, principal)\n                   .run(() -> Application.handle(request, response));\n    }\n}"
                }
              ],
              "sources": [
                {
                  "cluster_description": "These rules all advocate for preferring ScopedValue over ThreadLocal when sharing immutable data in a one-way transmission pattern from caller to callees, citing benefits of better performance, bounded lifetime, and clearer semantics.",
                  "original_ideas": [
                    {
                      "rule_title": "Prefer ScopedValue over ThreadLocal for one-way data transmission",
                      "rule_idea": "When the use case involves one-way transmission of immutable data from caller to callees, prefer ScopedValue over ThreadLocal for better performance, bounded lifetime, and clearer semantics.",
                      "code_examples": [
                        {
                          "non_compliant": "private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();\nvoid serve() {\n    CONTEXT.set(\"value\");\n    handle();\n}",
                          "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();\nvoid serve() {\n    where(CONTEXT, \"value\").run(() -> handle());\n}"
                        }
                      ],
                      "sources": [
                        {
                          "url": "https://openjdk.org/jeps/506",
                          "source_text": "# JEP 506: Scoped Values\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 25  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2025/03/24 10:10  \nUpdated | 2025/06/06 13:57  \nIssue | [8352695](https://bugs.openjdk.org/browse/JDK-8352695)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 505](https://openjdk.org/jeps/505)).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22), [JEP 481](https://openjdk.org/jeps/481) (JDK 23), and [JEP 487](https://openjdk.org/jeps/487) (JDK 24).\nWe here propose to finalize the scoped values API in JDK 25, with one small change: The `ScopedValue.orElse` method no longer accepts `null` as its argument.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 505](https://openjdk.org/jeps/505)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 505](https://openjdk.org/jeps/505#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/506#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nWe also experimented with a version of scoped-value binding that supports the `AutoCloseable` interface, and so could be used in a `try`-with-resources construct. We ultimately rejected that idea because it is impossible to guarantee correct operation when relying on user code to invoke the `close` method at the right time. Also, even if that method is invoked as designed, by a `try`-with-resources construct, the operation may immediately fail with a `StackOverflowError`, leaving the program in an inconsistent state. Integrity, even in the case of `StackOverflowError`, is more important than the convenience of `try`-with-resources. The functional interfaces used by the `run` and `call` methods in this API allow us to guarantee integrity while still being reasonably easy to use.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                        }
                      ],
                      "related_rules": []
                    },
                    {
                      "rule_title": "Prefer ScopedValue over ThreadLocal for one-way data sharing",
                      "rule_idea": "When ThreadLocal variables are used only for one-way transmission of unchanging data from caller to callees, ScopedValue should be preferred as it provides better performance, bounded lifetime, and immutability guarantees.",
                      "code_examples": [
                        {
                          "non_compliant": "class Server {\n    final static ThreadLocal<Principal> PRINCIPAL = new ThreadLocal<>();\n    \n    void serve(Request request, Response response) {\n        var principal = new Principal(request.isAdmin() ? ADMIN : GUEST);\n        PRINCIPAL.set(principal);\n        Application.handle(request, response);\n        // Missing remove() call - potential memory leak\n    }\n}",
                          "compliant": "class Server {\n    final static ScopedValue<Principal> PRINCIPAL = ScopedValue.newInstance();\n    \n    void serve(Request request, Response response) {\n        var principal = new Principal(request.isAdmin() ? ADMIN : GUEST);\n        ScopedValue.where(PRINCIPAL, principal)\n                   .run(() -> Application.handle(request, response));\n    }\n}"
                        }
                      ],
                      "sources": [
                        {
                          "url": "https://openjdk.org/jeps/429",
                          "source_text": "# JEP 429: Scoped Values (Incubator)\nAuthors | Andrew Haley, Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | JDK  \nStatus | Closed / Delivered  \nRelease | 20  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot java dot net  \nRelates to | [JEP 446: Scoped Values (Preview)](https://openjdk.org/jeps/446)  \nReviewed by | Alan Bateman, Alex Buckley  \nEndorsed by | John Rose  \nCreated | 2021/03/04 11:03  \nUpdated | 2023/11/29 14:40  \nIssue | [8263012](https://bugs.openjdk.org/browse/JDK-8263012)  \n## Summary\nIntroduce _scoped values_ , which enable the sharing of immutable data within and across threads. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is an [incubating API](https://openjdk.org/jeps/11).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Treat shared data as immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nLarge Java programs typically consist of distinct and complementary components that need to share data between themselves. For example, a web framework might include a server component, implemented in the `Principal` object shared between components. The server component creates a `Principal` for each thread that handles a request, and the data access component refers to a thread's `Principal` to control access to the database.\nThe diagram below shows the framework handling two requests, each in its own thread. Request handling flows upward, from the server component (`Server.serve(...)`) to user code (`Application.handle(...)`) to the data access component (`DBAccess.open()`). The data access component determines whether the thread is permitted to access the database, as follows:\n  * In Thread 1, the `ADMIN` principal created by the server component allows database access. The dashed line indicates the principal is to be shared with the data access component, which inspects it and proceeds to call `DBAccess.newConnection()`.\n  * In Thread 2, the `GUEST` principal created by the server component does not allow database access. The data access component inspects the principal, determines that the user code must not proceed, and throws an `InvalidPrincipalException`.\n\n\n```\nThread 1                                 Thread 2\n--------                                 --------\n8. DBAccess.newConnection()              8. throw new InvalidPrincipalException()\n7. DBAccess.open() <----------+          7. DBAccess.open() <----------+\n   ...                        |             ...                        |\n   ...                  Principal(ADMIN)    ...                  Principal(GUEST)\n2. Application.handle(..)     |          2. Application.handle(..)     |\n1. Server.serve(..) ----------+          1. Server.serve(..) ----------+\n```\n\nNormally, data is shared between caller and callee by passing it as method arguments, but this is not viable for a `Principal` shared between the server component and the data access component because the server component calls untrusted user code first. We need a better way to share data from the server component to the data access component than wiring it into a cascade of untrusted method invocations.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help components share data without resorting to method arguments. A thread-local variable is a variable of type `get()` or `set(...)` methods to read or write its value. Code in one thread automatically reads and writes its incarnation, while code in another thread automatically reads and writes its own distinct incarnation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from many components.\nHere is an example of how the server component and the data access component, both running in the same request-handling thread, can use a thread-local variable to share a `Principal`. The server component first declares a thread-local variable, `PRINCIPAL` (1). When `Server.serve(...)` is executed in a request-handling thread, it writes a suitable `Principal` to the thread-local variable (2), then calls user code. If and when user code calls `DBAccess.open()`, the data access component reads the thread-local variable (3) to obtain the `Principal` of the request-handling thread. Only if the `Principal` indicates suitable permissions is database access permitted (4).\n```\nclass Server {\n    final static ThreadLocal<Principal> PRINCIPAL = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAuthorized() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        PRINCIPAL.set(principal);                                         // (2)\n        Application.handle(request, response);\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                           // (3)\n        if (!principal.canOpen()) throw new InvalidPrincipalException();\n        return newConnection(...);                                        // (4)\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `Principal` as a method argument when the server component calls user code, and when user code calls the data access component. The thread-local variable serves as a kind of hidden method argument: A thread which calls `PRINCIPAL.set(...)` in `Server.serve(...)` and then `PRINCIPAL.get()` in `DBAccess.open()` will automatically see its own incarnation of the `PRINCIPAL` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `Principal` value for the current thread.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get()` method of a thread-local variable can call the `set(...)` method of that variable at any time. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between components. However, this can lead to spaghetti-like data flow, and to programs in which it is hard to discern which component updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one component to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's incarnation of a thread-local variable is written via the `set(...)` method, the incarnation is retained for the lifetime of the thread, or until code in the thread calls the `remove()` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because thread-local variables are mutable, and the `ThreadLocal` API requires that mutation in one thread is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set(...)` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads (`Server.serve(...)`, `Application.handle(...)`, and `DBAccess.open()` would all execute in a new virtual thread for each incoming request.\nIt would obviously be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has mutable thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain immutable and inheritable per-thread data for thousands or millions of virtual threads. Because these per-thread variables would be immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between components in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many components.\nLike a thread-local variable, a scoped value has multiple incarnations, one per thread. The particular incarnation that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once and is then immutable, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where(...)`, presenting a scoped value and the object to which it is to be bound. The call to `run(...)` _binds_ the scoped value, providing an incarnation that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run(...)` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run(...)` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe syntactic structure of the code delineates the period of time when a thread can read its incarnation of a scoped value. This bounded lifetime, combined with immutability, greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set(...)` method that lets faraway code change the scoped value at any time. Immutability also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. This is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run(...)` method produces an incarnation of V that is usable by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run(...)`. The unfolding execution of those methods defines a dynamic scope; the incarnation is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the server component declares a scoped value instead of a thread-local variable. At (2), the server component calls `ScopedValue.where(...)` and `run(...)` instead of a thread-local variable's `set(...)` method.\n```\nclass Server {\n    final static ScopedValue<Principal> PRINCIPAL =  ScopedValue.newInstance(); // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAdmin() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        ScopedValue.where(PRINCIPAL, principal)                            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (3)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\nTogether, `where(...)` and `run(...)` provide one-way sharing of data from the server component to the data access component. The scoped value passed to `where(...)` is bound to the corresponding object for the lifetime of the `run(...)` call, so `PRINCIPAL.get()` in any method called from `run(...)` will read that value. Accordingly, when `Server.serve(...)` calls user code, and user code calls `DBAccess.open()`, the value read from the scoped value (3) is the value written by `Server.serve(...)` earlier in the thread.\nThe binding established by `run(...)` is usable only in code called from `run(...)`. If `PRINCIPAL.get()` appeared in `Server.serve(...)` after the call to `run(...)`, an exception would be thrown because `PRINCIPAL` is no longer bound in the thread.\n### Rebinding scoped values\nThe immutability of scoped values means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees in the thread. The `ScopedValue` API allows a new binding to be established for nested calls.\nAs an example, consider a third component of the web framework: a logging component with a method `void log(Supplier<String> formatter)`. User code passes a lambda expression to the `log(...)` method; if logging is enabled, the method calls `formatter.get()` to evaluate the lambda expression and then prints the result. Although the user code may have permission to access the database, the lambda expression should not, since it only needs to format text. Accordingly, the scoped value that was initially bound in `Server.serve(...)` should be rebound to a guest `Principal` for the lifetime of `formatter.get()`:\n```\n8. InvalidPrincipalException()\n7. DBAccess.open() <--------------------------+  X---------+\n   ...                                        |            |\n   ...                                  Principal(GUEST)   |\n4. Supplier.get()                             |            |\n3. Logger.log(() -> { DBAccess.open(); }) ----+      Principal(ADMIN)\n2. Application.handle(..)                                  |\n1. Server.serve(..) ---------------------------------------+\n```\n\nHere is the code for `log(...)` with rebinding. It obtains a guest `Principal` (1) and passes it as the new binding for the scoped value `PRINCIPAL` (2). For the lifetime of the invocation of `call` (3), `PRINCIPAL.get()` will read this new value. Thus, if the user code passes a malicious lambda expression to `log(...)` that performs `DBAccess.open()`, the check in `DBAccess.open()` will read the guest `Principal` from `PRINCIPAL` and throw an `InvalidPrincipalException`.\n```\nclass Logger {\n    void log(Supplier<String> formatter) {\n        if (loggingEnabled) {\n            var guest = Principal.createGuest();                      // (1)\n            var message = ScopedValue.where(Server.PRINCIPAL, guest)  // (2)\n                                     .call(() -> formatter.get());    // (3)\n            write(logFile, \"%s %s\".format(timeStamp(), message));\n        }\n    }\n}\n```\n\n(We here use `call(...)` instead of `run(...)` to invoke the formatter because the result of the lambda expression is needed.) The syntactic structure of `where(...)` and `call(...)` means that the rebinding is only visible in the nested dynamic scope introduced by `call(...)`. The body of `log(...)` cannot change the binding seen by that method itself but can change the binding seen by its callees, such as the `formatter.get(...)` method. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread can execute framework code from the server component, then user code from the application developer, then more framework code from the data access component. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nData shared by a component running in the request-handling thread needs to be available to components running in child threads. Otherwise, when user code running in a child thread calls the data access component, that component \u2014 now also running in the child thread \u2014 will be unable to check the `Principal` shared by the server component running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API (`StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code, in a variant of the `Application.handle(...)` method called from `Server.serve(...)`. The user code calls `StructuredTaskScope.fork(...)` (1, 2) to run the `findUser()` and `fetchOrder()` methods concurrently, in their own virtual threads. Each method calls the data access component (3), which as before consults the scoped value `PRINCIPAL` (4). Further details of the user code are not discussed here; see \n```\nclass Application {\n    Response handle() throws ExecutionException, InterruptedException {\n        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n            Future<String>  user  = scope.fork(() -> findUser());          // (1)\n            Future<Integer> order = scope.fork(() -> fetchOrder());        // (2)\n            scope.join().throwIfFailed();  // Wait for both forks\n            return new Response(user.resultNow(), order.resultNow());\n        }\n    }\n\n    String findUser() {\n        ... DBAccess.open() ...                                            // (3)\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (4)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\n`StructuredTaskScope.fork(...)` ensures that the binding of the scoped value `PRINCIPAL` made in the request-handling thread \u2014 [when Server.serve(...) called ScopedValue.where(...)](https://openjdk.org/jeps/429#Web-framework-example-ScopedValue-code) \u2014 is automatically visible to `PRINCIPAL.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                           Thread 2\n--------                           --------\n                                   8. DBAccess.newConnection()\n                                   7. DBAccess.open() <----------+\n                                   ...                           |\n                                   ...                     Principal(ADMIN)\n                                   4. Application.findUser()     |\n3. StructuredTaskScope.fork(..)                                  |\n2. Application.handle(..)                                        |\n1. Server.serve(..) ---------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run(...)` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where(...)` and `run(...)`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set(...)` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                        }
                      ],
                      "related_rules": []
                    },
                    {
                      "rule_title": "Prefer ScopedValue over ThreadLocal for one-way data transmission",
                      "rule_idea": "When the purpose is one-way transmission of unchanging data from caller to callees, ScopedValue should be preferred over ThreadLocal for better performance, bounded lifetime, and immutability.",
                      "code_examples": [
                        {
                          "non_compliant": "private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();\n\nvoid serve() {\n    CONTEXT.set(\"value\");\n    processRequest();\n    CONTEXT.remove();\n}",
                          "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();\n\nvoid serve() {\n    ScopedValue.where(CONTEXT, \"value\").run(() -> processRequest());\n}"
                        }
                      ],
                      "sources": [
                        {
                          "url": "https://openjdk.org/jeps/446",
                          "source_text": "# JEP 446: Scoped Values (Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 21  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 429: Scoped Values (Incubator)](https://openjdk.org/jeps/429)  \n| [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \nReviewed by | Alan Bateman, Mark Reinhold  \nEndorsed by | Brian Goetz  \nCreated | 2023/03/16 16:01  \nUpdated | 2023/11/29 14:41  \nIssue | [8304357](https://bugs.openjdk.org/browse/JDK-8304357)  \n## Summary\nIntroduce _scoped values_ , values that may be safely and efficiently shared to methods without using method parameters. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is a [preview API](https://openjdk.org/jeps/12).\nIn effect, a scoped value is an _implicit method parameter_. It is \"as if\" every method in a sequence of calls has an additional, invisible, parameter. None of the methods declare this parameter and only the methods that have access to the scoped value object can access its value (the data). Scoped values make it possible to pass data securely from a caller to a faraway callee through a sequence of intermediate methods that do not declare a parameter for the data and have no access to the data.\n## History\nScoped Values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429). In JDK 21 this feature is no longer incubating; instead, it is a [preview API](https://openjdk.org/jeps/12).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Allow shared data to be immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing them as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may need to maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the context object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework wishes to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during re-design of the framework, adding it requires not only the immediate clients -- those user methods that directly call framework methods or those that are directly called by it -- to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method arguments. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Code in one thread automatically reads and writes its value, while code in another thread automatically reads and writes its own distinct instantiation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from different methods, and `private` so that it cannot be directly accessed by client (user) code.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`.\nThe framework declares a thread-local variable, `CONTEXT` (1). When`Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method argument: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct instantiation in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 425](https://openjdk.org/jeps/425)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating-system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived [non-pooled](https://openjdk.org/jeps/425#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between methods in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many methods.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Frameowrk {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, `bar` sees the `\"hello\"` binding. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 428](https://openjdk.org/jeps/428)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 428](https://openjdk.org/jeps/428#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/446#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of ScopedValues because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                        }
                      ],
                      "related_rules": []
                    },
                    {
                      "rule_title": "Prefer ScopedValue over ThreadLocal for one-way data sharing",
                      "rule_idea": "When ThreadLocal is used only for one-way data transmission from caller to callees without mutation, it should be replaced with ScopedValue for better performance, bounded lifetime, and clearer semantics.",
                      "code_examples": [
                        {
                          "non_compliant": "private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();\n\npublic void serve() {\n    CONTEXT.set(\"value\");\n    processRequest();\n    CONTEXT.remove();\n}",
                          "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();\n\npublic void serve() {\n    ScopedValue.where(CONTEXT, \"value\").run(() -> processRequest());\n}"
                        }
                      ],
                      "sources": [
                        {
                          "url": "https://openjdk.org/jeps/464",
                          "source_text": "# JEP 464: Scoped Values (Second Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 22  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 446: Scoped Values (Preview)](https://openjdk.org/jeps/446)  \n| [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2023/10/26 12:05  \nUpdated | 2025/02/25 16:32  \nIssue | [8318898](https://bugs.openjdk.org/browse/JDK-8318898)  \n## Summary\nIntroduce _scoped values_ , which enable managed sharing of immutable data both with child frames in the same thread, and with child threads. Scoped values are easier to reason about than thread-local variables and have lower space and time costs, especially when used in combination with [Virtual Threads](https://openjdk.org/jeps/444) and [Structured Concurrency](https://openjdk.org/jeps/462). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nScoped values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429) and became a preview API in JDK 21 via [JEP 446](https://openjdk.org/jeps/446). We here propose to re-preview the API in JDK 22, without change, in order to gain additional experience and feedback.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data is visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller can only be retrieved by legitimate callees.\n  * _Performance_ \u2014 Data can be efficiently shared across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a final static field and its accessibility is set to private, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. Although a thread-local variable solves the problem of sharing data private between a caller and an indirect callee this solution suffers from some drawbacks, which are described in more detail in the discussion that follows the example. In summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided.\nThe framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set()` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set()` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `final` `static` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(NAME, <value>)\n           .run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Framework {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 453](https://openjdk.org/jeps/453)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 453](https://openjdk.org/jeps/453#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/464#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, an instance of `java.text.SimpleDateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. Today, though, any code caching a `SimpleDateFormat` could move to using `DateTimeFormatter` because it can be stored in a `static final` field and shared between threads.\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the small subset described above. While this JEP only presents examples that use `ScopedValue<V>.where(V, <value>).run(aRunnable)`, there are more ways to bind a scoped value. For example, the API also provides a `Callable` version which returns a value and may also throw an `Exception`:\n```\ntry {\n        var result = ScopedValue.where(X, \"hello\").call(() -> bar());\n        catch (Exception e) {\n            handleFailure(e);\n        }\n        ...\n```\n\nAdditionally, there are abbreviated versions of the binding methods. For example, `ScopedValue<V>.runWhere(V, <value>, aRunnable)` is a short form of `ScopedValue<V>.where(V, <value>).run(aRunnable)`. While this short form is sometimes convenient, it only allows a single scoped value to be bound at a time.\nThe full scoped value API is to be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. Scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                        }
                      ],
                      "related_rules": []
                    },
                    {
                      "rule_title": "Prefer ScopedValue over ThreadLocal for immutable data sharing",
                      "rule_idea": "ScopedValue provides lower space and time costs compared to ThreadLocal variables when sharing immutable data within and across threads. This rule suggests replacing ThreadLocal usage with ScopedValue when the data is immutable and fits the scoped value pattern.",
                      "code_examples": [
                        {
                          "non_compliant": "private static final ThreadLocal<String> threadLocalValue = new ThreadLocal<>();\n// Using ThreadLocal for immutable data",
                          "compliant": "private static final ScopedValue<String> scopedValue = ScopedValue.newInstance();\n// Using ScopedValue for better performance with immutable data"
                        }
                      ],
                      "sources": [
                        {
                          "url": "https://www.infoworld.com/article/3846172/jdk-25-the-new-features-in-java-25.html",
                          "source_text": "by [Paul Krill](https://www.infoworld.com/profile/paul-krill/)\nEditor at Large\nUpdated \n# JDK 25: The new features in Java 25\nnews\nSep 16, 202513 mins\n[Java](https://www.infoworld.com/java/)[Programming Languages](https://www.infoworld.com/programming-languages/)[Software Development](https://www.infoworld.com/software-development/)\n##  Long-Term Support release, with features ranging from structured concurrency and compact object headers to ahead-of-time method profiling and JFR CPU-time profiling on Linux, is now generally available. \nCredit: \nJava Development Kit (JDK) 25, a new Long-Term Support (LTS) release of standard Java, is now generally available. The release brings 18 features, five of which Oracle touts as assisting with AI development.\nJDK 25 comes on the heels of [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html), a six-month-support release that arrived March 18. As a Long-Term support release, JDK 25 will get at least eight years of [JDK 21](https://www.infoworld.com/article/2338097/jdk-21-the-new-features-in-java-21.html), which arrived in September 2023.\nJDK 25 can be downloaded from \nFive of these features aid in the development of AI applications, Oracle said. Primitive types in patterns, instanceof, and switch make integrating business logic with primitive types from AI easier, according to the company. Module import declarations offer easier integration of business logic with AI inference, libraries, or service calls, while the Vector API often is used in AI inference and compute scenarios. Structured concurrency fits in with AI because AI development often involves running multiple tasks in parallel. And scoped values enable sharing of immutable data within and across threads with lower space and time costs versus thread-local variables, Oracle said.\nWith [PEM](https://www.infoworld.com/article/3846172/%5C%22/en.wikipedia.org/wiki/Privacy-Enhanced_Mail%22%5C%22) format transport, and for decoding from the format back into objects. The Java platform has not had an easy-to-use API for decoding and encoding in the PEM format. A main goal of the feature is ease of use. Another goal is support for conversions between PEM text and cryptographic objects that have standard representations in the binary formats \n[planned for JDK 21 in 2023 but was dropped](https://www.infoworld.com/article/2338620/java-21-to-drop-generational-shenandoah-gc-feature.html) because the capability was deemed not ready at the time.\n[ahead-of-time class loading and linking](https://www.infoworld.com/article/3482187/ahead-of-time-class-loading-proposal-would-speed-java-startups.html) in JDK 24.\nA third preview of `instanceof` and `switch` to work with all primitive types. The intent is to help developers increase Java programming productivity by making Java more uniform and expressive. Originally proposed in [JDK 23](https://www.infoworld.com/article/2336682/jdk-23-the-new-features-in-java-23.html) and followed up in JDK 24, this would still be a preview language feature in JDK 25. Among goals are enabling data exploration by allowing type patterns for all types, whether primitive or reference, and providing easy-to-use constructs that eliminate the risk of losing information due to unsafe casts.\n[JDK 20](https://www.infoworld.com/article/2336904/jdk-20-whats-next-for-java.html), proposed for preview in [JDK 21](https://www.infoworld.com/article/2338097/jdk-21-the-new-features-in-java-21.html), and subsequently refined for [JDK 22](https://www.infoworld.com/article/2335077/jdk-22-the-new-features-in-java-22.html) through [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html). The feature will be finalized in JDK 25, with one change: the `ScopedValue.orElse` method no longer accepts `null` as its argument.\nThe [JDK 16](https://www.infoworld.com/article/2259413/jdk-16-the-new-features-in-java-16.html). Two notable implementation changes are featured in the JDK 25 implementation of the API. First, the implementation now links to native mathematical-function libraries via the [C++](https://www.infoworld.com/article/2338049/c-23-language-standard-declared-feature-complete.html) code inside the HotSpot JVM, thus improving maintainability. Second, addition, subtraction, division, multiplication, square root, and fused multiply/add operations on `Float16` values now are auto-vectorized on supporting x64 CPUs. Additionally, **`VectorShuffle `**now supports access to and from`MemorySegment`.\nThe \n[JDK 21](https://www.infoworld.com/article/2338097/jdk-21-the-new-features-in-java-21.html) through [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html), after being incubated in [JDK 19](https://www.infoworld.com/article/2334631/jdk-19-the-new-features-in-java-19.html) and `StructuredTaskScope` that waits for all subtasks to succeed or any subtask to fail.\n[JDK 22](https://www.infoworld.com/article/2335077/jdk-22-the-new-features-in-java-22.html) as \u201cstatements before super(\u2026)\u201d as well as in [JDK 23](https://www.infoworld.com/article/2336682/jdk-23-the-new-features-in-java-23.html) and [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html). The feature is intended to be finalized in JDK 25. In flexible constructor bodies, the body of a constructor allows statements to appear before an explicit constructor invocation such as `super (\u2026)` or `this (\u2026)`.\nSeparate from the `String`, by allowing the `String::hashCode` function to take advantage of a compiler optimization called constant folding. Developers who use strings as keys in a static unmodifiable `Map` should see significant performance boosts, according to a May 1 article on Oracle\u2019s \n## Related content\n### [Smoother Kubernetes sailing with AKS Automatic By Simon Bisson Sep 18, 2025 8 mins ](https://www.infoworld.com/article/4058764/smoother-kubernetes-sailing-with-aks-automatic.html) ### [Software developers aren\u2019t buying it By Nick Hodges Sep 17, 2025 5 mins ](https://www.infoworld.com/article/4058058/software-developers-arent-buying-it.html) ### [Rust tutorial: Get started with the Rust language By Serdar Yegulalp Sep 17, 2025 15 mins ](https://www.infoworld.com/article/2258463/rust-tutorial-get-started-with-the-rust-language.html) ### [Is AI the 4GL we\u2019ve been waiting for? By Matthew Tyson Sep 17, 2025 7 mins ](https://www.infoworld.com/article/4049946/is-ai-the-4gl-weve-been-waiting-for.html)\nby [ Paul Krill ](https://www.infoworld.com/profile/paul-krill/)\nEditor at Large\nPaul Krill is editor at large at InfoWorld. Paul has been covering computer technology as a news and feature reporter for more than 35 years, including 30 years at InfoWorld. He has specialized in coverage of software development tools and technologies since the 1990s, and he continues to lead InfoWorld\u2019s news coverage of software development platforms including Java and .NET and programming languages including JavaScript, TypeScript, PHP, Python, Ruby, Rust, and Go. Long trusted as a reporter who prioritizes accuracy, integrity, and the best interests of readers, Paul is sought out by technology companies and industry organizations who want to reach InfoWorld\u2019s audience of software developers and other information technology professionals. Paul has won a \u201cBest Technology News Coverage\u201d award from IDG. \n## More from this author\n  * [news San Francisco AI technology conference draws protests Sep 18, 2025 2 mins ](https://www.infoworld.com/article/4058978/san-francisco-ai-technology-conference-draws-protests.html)\n  * [news Visual Studio 2026 doubles down on AI-assisted coding Sep 16, 2025 2 mins ](https://www.infoworld.com/article/4058164/visual-studio-2026-doubles-down-on-ai-assisted-coding.html)\n  * [news Survey pinpoints Rust compiler pain points Sep 15, 2025 3 mins ](https://www.infoworld.com/article/4057215/survey-pinpoints-rust-compiler-pain-points.html)\n  * [news Kotlin 2.2.20 boosts WebAssembly support Sep 12, 2025 2 mins ](https://www.infoworld.com/article/4056077/kotlin-2-2-20-boosts-webassembly-support.html)\n  * [news VS Code 1.104 emphasizes AI model selection, agent security Sep 11, 2025 3 mins ](https://www.infoworld.com/article/4056026/vs-code-1-104-emphasizes-ai-model-selection-agent-security.html)\n  * [news JFrog announces \u2018agentic repo\u2019 for AI-driven development Sep 10, 2025 2 mins ](https://www.infoworld.com/article/4055080/jfrog-announces-agentic-repo-for-ai-driven-development.html)\n  * [news .NET 10 moves to release candidate stage Sep 10, 2025 3 mins ](https://www.infoworld.com/article/4054199/net-10-moves-to-release-candidate-stage.html)\n  * [news JDK 26: The new features in Java 26 Sep 9, 2025 3 mins ](https://www.infoworld.com/article/4050993/jdk-26-the-new-features-in-java-26.html)\n\n\n## Show me more\nPopularArticlesVideos\n[ feature Designing AI-ready architectures in compliance-heavy environments By Rama Devi Drakshpalli Sep 18, 202512 mins Artificial IntelligenceData GovernanceData and Information Security ](https://www.infoworld.com/article/4058747/designing-ai-ready-architectures-in-compliance-heavy-environments.html)\n[ news MongoDB adds vector search to self-managed editions to power generative AI apps By Anirban Ghoshal Sep 17, 20253 mins DatabasesNoSQL Databases ](https://www.infoworld.com/article/4058564/mongodb-adds-vector-search-to-self-managed-editions-to-power-generative-ai-apps.html)\n[ feature The rise of AI-ready private clouds By Mark Cusack Sep 17, 202511 mins ContainersKubernetesMachine Learning ](https://www.infoworld.com/article/4057189/the-rise-of-ai-ready-private-clouds.html)\n[ video Easier Chrome browser automation with PyDoll Sep 16, 20254 mins Python ](https://www.infoworld.com/video/4057906/easier-chrome-browser-automation-with-pydoll.html)\n[ video How to use Rust workspaces to speed up compile times Sep 9, 20253 mins Python ](https://www.infoworld.com/video/4054034/how-to-use-rust-workspaces-to-speed-up-compile-times.html)\n[ video Getting encryption wrong (and getting it right, too) Sep 2, 20257 mins Python ](https://www.infoworld.com/video/4049684/getting-encryption-wrong-and-getting-it-right-too.html)\nSponsored Links\n"
                        }
                      ],
                      "related_rules": []
                    }
                  ]
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Avoid ThreadLocal for immutable data sharing",
              "rule_idea": "When sharing immutable data that doesn't need to be modified by callees, avoid using ThreadLocal as it provides unnecessary mutability and use ScopedValue instead.",
              "code_examples": [
                {
                  "non_compliant": "class RequestProcessor {\n    private static final ThreadLocal<String> REQUEST_ID = new ThreadLocal<>();\n    \n    public void handleRequest(String requestId) {\n        REQUEST_ID.set(requestId); // Immutable data but using mutable ThreadLocal\n        processRequest();\n        REQUEST_ID.remove();\n    }\n}",
                  "compliant": "class RequestProcessor {\n    private static final ScopedValue<String> REQUEST_ID = ScopedValue.newInstance();\n    \n    public void handleRequest(String requestId) {\n        ScopedValue.where(REQUEST_ID, requestId)\n                   .run(this::processRequest);\n    }\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/429",
                  "source_text": "# JEP 429: Scoped Values (Incubator)\nAuthors | Andrew Haley, Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | JDK  \nStatus | Closed / Delivered  \nRelease | 20  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot java dot net  \nRelates to | [JEP 446: Scoped Values (Preview)](https://openjdk.org/jeps/446)  \nReviewed by | Alan Bateman, Alex Buckley  \nEndorsed by | John Rose  \nCreated | 2021/03/04 11:03  \nUpdated | 2023/11/29 14:40  \nIssue | [8263012](https://bugs.openjdk.org/browse/JDK-8263012)  \n## Summary\nIntroduce _scoped values_ , which enable the sharing of immutable data within and across threads. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is an [incubating API](https://openjdk.org/jeps/11).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Treat shared data as immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nLarge Java programs typically consist of distinct and complementary components that need to share data between themselves. For example, a web framework might include a server component, implemented in the `Principal` object shared between components. The server component creates a `Principal` for each thread that handles a request, and the data access component refers to a thread's `Principal` to control access to the database.\nThe diagram below shows the framework handling two requests, each in its own thread. Request handling flows upward, from the server component (`Server.serve(...)`) to user code (`Application.handle(...)`) to the data access component (`DBAccess.open()`). The data access component determines whether the thread is permitted to access the database, as follows:\n  * In Thread 1, the `ADMIN` principal created by the server component allows database access. The dashed line indicates the principal is to be shared with the data access component, which inspects it and proceeds to call `DBAccess.newConnection()`.\n  * In Thread 2, the `GUEST` principal created by the server component does not allow database access. The data access component inspects the principal, determines that the user code must not proceed, and throws an `InvalidPrincipalException`.\n\n\n```\nThread 1                                 Thread 2\n--------                                 --------\n8. DBAccess.newConnection()              8. throw new InvalidPrincipalException()\n7. DBAccess.open() <----------+          7. DBAccess.open() <----------+\n   ...                        |             ...                        |\n   ...                  Principal(ADMIN)    ...                  Principal(GUEST)\n2. Application.handle(..)     |          2. Application.handle(..)     |\n1. Server.serve(..) ----------+          1. Server.serve(..) ----------+\n```\n\nNormally, data is shared between caller and callee by passing it as method arguments, but this is not viable for a `Principal` shared between the server component and the data access component because the server component calls untrusted user code first. We need a better way to share data from the server component to the data access component than wiring it into a cascade of untrusted method invocations.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help components share data without resorting to method arguments. A thread-local variable is a variable of type `get()` or `set(...)` methods to read or write its value. Code in one thread automatically reads and writes its incarnation, while code in another thread automatically reads and writes its own distinct incarnation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from many components.\nHere is an example of how the server component and the data access component, both running in the same request-handling thread, can use a thread-local variable to share a `Principal`. The server component first declares a thread-local variable, `PRINCIPAL` (1). When `Server.serve(...)` is executed in a request-handling thread, it writes a suitable `Principal` to the thread-local variable (2), then calls user code. If and when user code calls `DBAccess.open()`, the data access component reads the thread-local variable (3) to obtain the `Principal` of the request-handling thread. Only if the `Principal` indicates suitable permissions is database access permitted (4).\n```\nclass Server {\n    final static ThreadLocal<Principal> PRINCIPAL = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAuthorized() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        PRINCIPAL.set(principal);                                         // (2)\n        Application.handle(request, response);\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                           // (3)\n        if (!principal.canOpen()) throw new InvalidPrincipalException();\n        return newConnection(...);                                        // (4)\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `Principal` as a method argument when the server component calls user code, and when user code calls the data access component. The thread-local variable serves as a kind of hidden method argument: A thread which calls `PRINCIPAL.set(...)` in `Server.serve(...)` and then `PRINCIPAL.get()` in `DBAccess.open()` will automatically see its own incarnation of the `PRINCIPAL` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `Principal` value for the current thread.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get()` method of a thread-local variable can call the `set(...)` method of that variable at any time. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between components. However, this can lead to spaghetti-like data flow, and to programs in which it is hard to discern which component updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one component to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's incarnation of a thread-local variable is written via the `set(...)` method, the incarnation is retained for the lifetime of the thread, or until code in the thread calls the `remove()` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because thread-local variables are mutable, and the `ThreadLocal` API requires that mutation in one thread is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set(...)` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads (`Server.serve(...)`, `Application.handle(...)`, and `DBAccess.open()` would all execute in a new virtual thread for each incoming request.\nIt would obviously be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has mutable thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain immutable and inheritable per-thread data for thousands or millions of virtual threads. Because these per-thread variables would be immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between components in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many components.\nLike a thread-local variable, a scoped value has multiple incarnations, one per thread. The particular incarnation that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once and is then immutable, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where(...)`, presenting a scoped value and the object to which it is to be bound. The call to `run(...)` _binds_ the scoped value, providing an incarnation that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run(...)` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run(...)` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe syntactic structure of the code delineates the period of time when a thread can read its incarnation of a scoped value. This bounded lifetime, combined with immutability, greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set(...)` method that lets faraway code change the scoped value at any time. Immutability also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. This is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run(...)` method produces an incarnation of V that is usable by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run(...)`. The unfolding execution of those methods defines a dynamic scope; the incarnation is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the server component declares a scoped value instead of a thread-local variable. At (2), the server component calls `ScopedValue.where(...)` and `run(...)` instead of a thread-local variable's `set(...)` method.\n```\nclass Server {\n    final static ScopedValue<Principal> PRINCIPAL =  ScopedValue.newInstance(); // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAdmin() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        ScopedValue.where(PRINCIPAL, principal)                            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (3)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\nTogether, `where(...)` and `run(...)` provide one-way sharing of data from the server component to the data access component. The scoped value passed to `where(...)` is bound to the corresponding object for the lifetime of the `run(...)` call, so `PRINCIPAL.get()` in any method called from `run(...)` will read that value. Accordingly, when `Server.serve(...)` calls user code, and user code calls `DBAccess.open()`, the value read from the scoped value (3) is the value written by `Server.serve(...)` earlier in the thread.\nThe binding established by `run(...)` is usable only in code called from `run(...)`. If `PRINCIPAL.get()` appeared in `Server.serve(...)` after the call to `run(...)`, an exception would be thrown because `PRINCIPAL` is no longer bound in the thread.\n### Rebinding scoped values\nThe immutability of scoped values means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees in the thread. The `ScopedValue` API allows a new binding to be established for nested calls.\nAs an example, consider a third component of the web framework: a logging component with a method `void log(Supplier<String> formatter)`. User code passes a lambda expression to the `log(...)` method; if logging is enabled, the method calls `formatter.get()` to evaluate the lambda expression and then prints the result. Although the user code may have permission to access the database, the lambda expression should not, since it only needs to format text. Accordingly, the scoped value that was initially bound in `Server.serve(...)` should be rebound to a guest `Principal` for the lifetime of `formatter.get()`:\n```\n8. InvalidPrincipalException()\n7. DBAccess.open() <--------------------------+  X---------+\n   ...                                        |            |\n   ...                                  Principal(GUEST)   |\n4. Supplier.get()                             |            |\n3. Logger.log(() -> { DBAccess.open(); }) ----+      Principal(ADMIN)\n2. Application.handle(..)                                  |\n1. Server.serve(..) ---------------------------------------+\n```\n\nHere is the code for `log(...)` with rebinding. It obtains a guest `Principal` (1) and passes it as the new binding for the scoped value `PRINCIPAL` (2). For the lifetime of the invocation of `call` (3), `PRINCIPAL.get()` will read this new value. Thus, if the user code passes a malicious lambda expression to `log(...)` that performs `DBAccess.open()`, the check in `DBAccess.open()` will read the guest `Principal` from `PRINCIPAL` and throw an `InvalidPrincipalException`.\n```\nclass Logger {\n    void log(Supplier<String> formatter) {\n        if (loggingEnabled) {\n            var guest = Principal.createGuest();                      // (1)\n            var message = ScopedValue.where(Server.PRINCIPAL, guest)  // (2)\n                                     .call(() -> formatter.get());    // (3)\n            write(logFile, \"%s %s\".format(timeStamp(), message));\n        }\n    }\n}\n```\n\n(We here use `call(...)` instead of `run(...)` to invoke the formatter because the result of the lambda expression is needed.) The syntactic structure of `where(...)` and `call(...)` means that the rebinding is only visible in the nested dynamic scope introduced by `call(...)`. The body of `log(...)` cannot change the binding seen by that method itself but can change the binding seen by its callees, such as the `formatter.get(...)` method. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread can execute framework code from the server component, then user code from the application developer, then more framework code from the data access component. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nData shared by a component running in the request-handling thread needs to be available to components running in child threads. Otherwise, when user code running in a child thread calls the data access component, that component \u2014 now also running in the child thread \u2014 will be unable to check the `Principal` shared by the server component running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API (`StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code, in a variant of the `Application.handle(...)` method called from `Server.serve(...)`. The user code calls `StructuredTaskScope.fork(...)` (1, 2) to run the `findUser()` and `fetchOrder()` methods concurrently, in their own virtual threads. Each method calls the data access component (3), which as before consults the scoped value `PRINCIPAL` (4). Further details of the user code are not discussed here; see \n```\nclass Application {\n    Response handle() throws ExecutionException, InterruptedException {\n        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n            Future<String>  user  = scope.fork(() -> findUser());          // (1)\n            Future<Integer> order = scope.fork(() -> fetchOrder());        // (2)\n            scope.join().throwIfFailed();  // Wait for both forks\n            return new Response(user.resultNow(), order.resultNow());\n        }\n    }\n\n    String findUser() {\n        ... DBAccess.open() ...                                            // (3)\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (4)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\n`StructuredTaskScope.fork(...)` ensures that the binding of the scoped value `PRINCIPAL` made in the request-handling thread \u2014 [when Server.serve(...) called ScopedValue.where(...)](https://openjdk.org/jeps/429#Web-framework-example-ScopedValue-code) \u2014 is automatically visible to `PRINCIPAL.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                           Thread 2\n--------                           --------\n                                   8. DBAccess.newConnection()\n                                   7. DBAccess.open() <----------+\n                                   ...                           |\n                                   ...                     Principal(ADMIN)\n                                   4. Application.findUser()     |\n3. StructuredTaskScope.fork(..)                                  |\n2. Application.handle(..)                                        |\n1. Server.serve(..) ---------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run(...)` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where(...)` and `run(...)`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set(...)` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Replace ThreadLocal.set with ScopedValue.runWhere",
              "rule_idea": "When migrating from ThreadLocal to ScopedValue, replace ThreadLocal.set() calls with ScopedValue.runWhere() to establish bounded scoped bindings instead of unbounded thread-local assignments.",
              "code_examples": [
                {
                  "non_compliant": "CONTEXT.set(contextValue);\nprocessRequest();",
                  "compliant": "ScopedValue.runWhere(CONTEXT, contextValue, () -> processRequest());"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/481",
                  "source_text": "# JEP 481: Scoped Values (Third Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 23  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \n| [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2024/04/24 14:31  \nUpdated | 2025/02/25 16:32  \nIssue | [8331056](https://bugs.openjdk.org/browse/JDK-8331056)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429), became a preview API in JDK 21 via [JEP 446](https://openjdk.org/jeps/446), and was re-previewed in JDK 22 via [JEP 464](https://openjdk.org/jeps/464).\nWe here propose to re-preview the API in JDK 23 in order to gain additional experience and feedback, with one change:\n  * The type of the operation parameter of the [`ScopedValue.callWhere`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html#callWhere\\(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp\\)) method is now a new functional interface which allows the Java compiler to infer whether a checked exception might be thrown. With this change, the \n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `final` `static` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type [`ScopedValue`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html). It is typically declared as a `final` `static` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.runWhere`, presenting a scoped value and the object to which it is to be bound. The call to `runWhere` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as an argument. During the lifetime of the `runWhere` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `runWhere` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method\nScopedValue.runWhere(NAME, <value>,\n    () -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `runWhere` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `runWhere`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.runWhere` instead of a thread-local variable's `set` method.\n```\nclass Framework {\n\n    private final static ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.runWhere(CONTEXT, context,          // (2)\n                   () -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nThe `runWhere` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `runWhere` is bound to the corresponding object for the lifetime of the `runWhere` call, so `CONTEXT.get()` in any method called from `runWhere` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `runWhere` is usable only in code called from `runWhere`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `runWhere`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.runWhere(X, \"hello\", () -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.runWhere(X, \"goodbye\", () -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/481#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.runWhere`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `runWhere` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.runWhere`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the small subset described above. While here we only present examples that use `ScopedValue<V>.runWhere(V, <value>, aRunnable)`, there are more ways to bind a scoped value. For example, the API also provides a version which returns a value and may also throw an `Exception`:\n```\ntry {\n        var result = ScopedValue.callWhere(X, \"hello\", () -> bar());\n        catch (Exception e) {\n            handleFailure(e);\n        }\n        ...\n```\n\nAdditionally, there are versions of the binding methods that can bind multiple scoped values at a call site.\nThe following example runs an operation with k1 bound (or rebound) to v1, and k2 bound (or rebound) to v2:\n```\nScopedValue.where(k1, v1).where(k2, v2).run(\n        () -> ... );\n```\n\nThis is both more efficient and much easier to read than nested invocations of `ScopedValue.runWhere`.\nThe full scoped value API can be found [here](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html).\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            }
          ]
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 0
      },
      "classification": "-",
      "action": " ",
      "index": 0,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "ScopedValue should be declared as static final",
      "rule_idea": "ScopedValue instances should be declared as static final fields to ensure they serve as proper keys for thread-local data sharing and cannot be reassigned. This follows the recommended pattern described in the JEP and prevents unexpected behavior and memory issues. Static final declaration ensures the ScopedValue can be shared across all instances of a class and accessed from different methods.",
      "code_examples": [
        {
          "non_compliant": "private ScopedValue<String> context = ScopedValue.newInstance();",
          "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();"
        },
        {
          "non_compliant": "public class UserService {\n    private ScopedValue<String> user = ScopedValue.newInstance();\n    \n    public void processUser() {\n        ScopedValue.where(user, \"Alice\").run(() -> {\n            System.out.println(\"User: \" + user.get());\n        });\n    }\n}",
          "compliant": "public class UserService {\n    private static final ScopedValue<String> USER = ScopedValue.newInstance();\n    \n    public void processUser() {\n        ScopedValue.where(USER, \"Alice\").run(() -> {\n            System.out.println(\"User: \" + USER.get());\n        });\n    }\n}"
        }
      ],
      "sources": [
        {
          "cluster_description": "Multiple variations of the same rule requiring ScopedValue instances to be declared as static final fields, with identical reasoning about proper key usage and following JEP recommendations.",
          "original_ideas": [
            {
              "rule_title": "Scoped values should be declared as static final fields",
              "rule_idea": "Scoped values should be declared as static final fields to ensure they serve as proper keys for thread-local data sharing. Non-static or non-final declarations can lead to unexpected behavior and memory issues.",
              "code_examples": [
                {
                  "non_compliant": "private ScopedValue<String> context = ScopedValue.newInstance();",
                  "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/506",
                  "source_text": "# JEP 506: Scoped Values\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 25  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2025/03/24 10:10  \nUpdated | 2025/06/06 13:57  \nIssue | [8352695](https://bugs.openjdk.org/browse/JDK-8352695)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 505](https://openjdk.org/jeps/505)).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22), [JEP 481](https://openjdk.org/jeps/481) (JDK 23), and [JEP 487](https://openjdk.org/jeps/487) (JDK 24).\nWe here propose to finalize the scoped values API in JDK 25, with one small change: The `ScopedValue.orElse` method no longer accepts `null` as its argument.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 505](https://openjdk.org/jeps/505)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 505](https://openjdk.org/jeps/505#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/506#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nWe also experimented with a version of scoped-value binding that supports the `AutoCloseable` interface, and so could be used in a `try`-with-resources construct. We ultimately rejected that idea because it is impossible to guarantee correct operation when relying on user code to invoke the `close` method at the right time. Also, even if that method is invoked as designed, by a `try`-with-resources construct, the operation may immediately fail with a `StackOverflowError`, leaving the program in an inconsistent state. Integrity, even in the case of `StackOverflowError`, is more important than the convenience of `try`-with-resources. The functional interfaces used by the `run` and `call` methods in this API allow us to guarantee integrity while still being reasonably easy to use.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "ScopedValue should be declared as final static",
              "rule_idea": "ScopedValue instances should be declared as final static fields to ensure they can be easily reached from different methods and cannot be reassigned. This follows the recommended pattern described in the JEP.",
              "code_examples": [
                {
                  "non_compliant": "private ScopedValue<String> context = ScopedValue.newInstance();",
                  "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/446",
                  "source_text": "# JEP 446: Scoped Values (Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 21  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 429: Scoped Values (Incubator)](https://openjdk.org/jeps/429)  \n| [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \nReviewed by | Alan Bateman, Mark Reinhold  \nEndorsed by | Brian Goetz  \nCreated | 2023/03/16 16:01  \nUpdated | 2023/11/29 14:41  \nIssue | [8304357](https://bugs.openjdk.org/browse/JDK-8304357)  \n## Summary\nIntroduce _scoped values_ , values that may be safely and efficiently shared to methods without using method parameters. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is a [preview API](https://openjdk.org/jeps/12).\nIn effect, a scoped value is an _implicit method parameter_. It is \"as if\" every method in a sequence of calls has an additional, invisible, parameter. None of the methods declare this parameter and only the methods that have access to the scoped value object can access its value (the data). Scoped values make it possible to pass data securely from a caller to a faraway callee through a sequence of intermediate methods that do not declare a parameter for the data and have no access to the data.\n## History\nScoped Values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429). In JDK 21 this feature is no longer incubating; instead, it is a [preview API](https://openjdk.org/jeps/12).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Allow shared data to be immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing them as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may need to maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the context object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework wishes to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during re-design of the framework, adding it requires not only the immediate clients -- those user methods that directly call framework methods or those that are directly called by it -- to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method arguments. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Code in one thread automatically reads and writes its value, while code in another thread automatically reads and writes its own distinct instantiation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from different methods, and `private` so that it cannot be directly accessed by client (user) code.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`.\nThe framework declares a thread-local variable, `CONTEXT` (1). When`Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method argument: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct instantiation in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 425](https://openjdk.org/jeps/425)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating-system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived [non-pooled](https://openjdk.org/jeps/425#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between methods in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many methods.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Frameowrk {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, `bar` sees the `\"hello\"` binding. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 428](https://openjdk.org/jeps/428)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 428](https://openjdk.org/jeps/428#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/446#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of ScopedValues because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "ScopedValue should be declared as final static field",
              "rule_idea": "ScopedValue instances should be declared as final static fields to ensure they serve as proper keys for thread-specific data lookup, similar to how ThreadLocal variables are typically declared.",
              "code_examples": [
                {
                  "non_compliant": "private ScopedValue<String> context = ScopedValue.newInstance();",
                  "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/481",
                  "source_text": "# JEP 481: Scoped Values (Third Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 23  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \n| [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2024/04/24 14:31  \nUpdated | 2025/02/25 16:32  \nIssue | [8331056](https://bugs.openjdk.org/browse/JDK-8331056)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429), became a preview API in JDK 21 via [JEP 446](https://openjdk.org/jeps/446), and was re-previewed in JDK 22 via [JEP 464](https://openjdk.org/jeps/464).\nWe here propose to re-preview the API in JDK 23 in order to gain additional experience and feedback, with one change:\n  * The type of the operation parameter of the [`ScopedValue.callWhere`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html#callWhere\\(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp\\)) method is now a new functional interface which allows the Java compiler to infer whether a checked exception might be thrown. With this change, the \n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `final` `static` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type [`ScopedValue`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html). It is typically declared as a `final` `static` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.runWhere`, presenting a scoped value and the object to which it is to be bound. The call to `runWhere` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as an argument. During the lifetime of the `runWhere` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `runWhere` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method\nScopedValue.runWhere(NAME, <value>,\n    () -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `runWhere` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `runWhere`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.runWhere` instead of a thread-local variable's `set` method.\n```\nclass Framework {\n\n    private final static ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.runWhere(CONTEXT, context,          // (2)\n                   () -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nThe `runWhere` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `runWhere` is bound to the corresponding object for the lifetime of the `runWhere` call, so `CONTEXT.get()` in any method called from `runWhere` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `runWhere` is usable only in code called from `runWhere`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `runWhere`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.runWhere(X, \"hello\", () -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.runWhere(X, \"goodbye\", () -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/481#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.runWhere`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `runWhere` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.runWhere`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the small subset described above. While here we only present examples that use `ScopedValue<V>.runWhere(V, <value>, aRunnable)`, there are more ways to bind a scoped value. For example, the API also provides a version which returns a value and may also throw an `Exception`:\n```\ntry {\n        var result = ScopedValue.callWhere(X, \"hello\", () -> bar());\n        catch (Exception e) {\n            handleFailure(e);\n        }\n        ...\n```\n\nAdditionally, there are versions of the binding methods that can bind multiple scoped values at a call site.\nThe following example runs an operation with k1 bound (or rebound) to v1, and k2 bound (or rebound) to v2:\n```\nScopedValue.where(k1, v1).where(k2, v2).run(\n        () -> ... );\n```\n\nThis is both more efficient and much easier to read than nested invocations of `ScopedValue.runWhere`.\nThe full scoped value API can be found [here](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html).\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Scoped values should be declared as static final fields",
              "rule_idea": "Scoped values should be declared as static final fields to ensure they serve as proper keys for value lookup and maintain immutability of the reference itself.",
              "code_examples": [
                {
                  "non_compliant": "private ScopedValue<String> context = ScopedValue.newInstance();",
                  "compliant": "private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();"
                }
              ],
              "sources": [
                {
                  "url": "https://bugs.openjdk.org/browse/JDK-8352695",
                  "source_text": "### Details\n  * ** Type: **\n  * **Resolution:** Delivered \n  * ** Priority: **\n  * ** Fix Version/s:  ** [25](https://bugs.openjdk.org/issues/?jql=project+%3D+JDK+AND+fixVersion+%3D+%2225%22 \"25 JDK 25\")\n  * ** Component/s: ** [core-libs](https://bugs.openjdk.org/issues/?jql=project+%3D+JDK+AND+component+%3D+core-libs \"core-libs \")\n  * ** Labels: **\n    * [jdk25-ptt-2025-05-15](https://bugs.openjdk.org/issues/?jql=labels+%3D+jdk25-ptt-2025-05-15 \"jdk25-ptt-2025-05-15\")\n    * [loom](https://bugs.openjdk.org/issues/?jql=labels+%3D+loom \"loom\")\n\n\n  * ** Author: **\nAndrew Haley & Andrew Dinn \n  * ** JEP Type: **\nFeature \n  * ** Exposure: **\nOpen \n  * ** Scope: **\nSE \n  * ** Discussion: **\nloom dash dev at openjdk dot org \n  * ** JEP Number: **\n506 \n\n\n### Description\n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 505](https://openjdk.org/jeps/505)).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22), [JEP 481](https://openjdk.org/jeps/481) (JDK 23), and [JEP 487](https://openjdk.org/jeps/487) (JDK 24).\nWe here propose to finalize the scoped values API in JDK 25, with one small change: The `ScopedValue.orElse` method no longer accepts `null` as its argument.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls. \nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service. \n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n\n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n  |\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`. \nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 505](https://openjdk.org/jeps/505)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 505](https://openjdk.org/jeps/505#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://bugs.openjdk.org/browse/JDK-8352695#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\n    try {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site: \n```\n    where(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nWe also experimented with a version of scoped-value binding that supports the `AutoCloseable` interface, and so could be used in a `try`-with-resources construct. We ultimately rejected that idea because it is impossible to guarantee correct operation when relying on user code to invoke the `close` method at the right time. Also, even if that method is invoked as designed, by a `try`-with-resources construct, the operation may immediately fail with a `StackOverflowError`, leaving the program in an inconsistent state. Integrity, even in the case of `StackOverflowError`, is more important than the convenience of `try`-with-resources. The functional interfaces used by the `run` and `call` methods in this API allow us to guarantee integrity while still being reasonably easy to use.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n### Attachments\n### Issue Links \n\nis blocked by\n    \n[JDK-8355022](https://bugs.openjdk.org/browse/JDK-8355022) Implement JEP 506: Scoped Values\n  * Resolved\n\n\n\nrelates to\n    \n[JDK-8338456](https://bugs.openjdk.org/browse/JDK-8338456) JEP 487: Scoped Values (Fourth Preview)\n  * Closed\n\n    \n[JDK-8355720](https://bugs.openjdk.org/browse/JDK-8355720) Implement JEP 506: Scoped Values\n  * Closed\n\n\n### Activity\n## [JDK-8352695] JEP 506: Scoped Values\n  * [All](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel)\n  * Comments\n  * [History](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel)\n  * [Activity](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab)\n\n\nThere are no comments yet on this issue. \n### People \n\nAssignee: \n\n\nReporter: \n\n\nOwner: \n     Andrew Haley \n\nReviewed By: \n    \nAlan Bateman \n\nEndorsed By: \n    \nPaul Sandoz \n\nVotes:\n     0 Vote for this issue \n\nWatchers:\n     8 Start watching this issue\n### Dates \n\nCreated: \n     2025-03-24 03:10 \n\nUpdated: \n     2025-06-06 06:57 \n\nResolved: \n     2025-06-06 06:57\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Scoped values should be declared as static final fields",
              "rule_idea": "Scoped values should be declared as static final fields to ensure they serve as proper keys for thread-local storage. Non-static or non-final scoped values can lead to unexpected behavior and memory leaks.",
              "code_examples": [
                {
                  "non_compliant": "public class Framework {\n    private ScopedValue<String> context = ScopedValue.newInstance();\n}",
                  "compliant": "public class Framework {\n    private static final ScopedValue<String> CONTEXT = ScopedValue.newInstance();\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/487",
                  "source_text": "# JEP 487: Scoped Values (Fourth Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 24  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \n| [JEP 506: Scoped Values](https://openjdk.org/jeps/506)  \nReviewed by | Alan Bateman, Brian Goetz  \nEndorsed by | Alan Bateman  \nCreated | 2024/08/15 16:18  \nUpdated | 2025/04/10 18:03  \nIssue | [8338456](https://bugs.openjdk.org/browse/JDK-8338456)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22) and [JEP 481](https://openjdk.org/jeps/481) (JDK 23).\nWe here propose to re-preview the API once more in JDK 24 in order to gain additional experience and feedback, with one further change:\n  * We removed the `callWhere` and `runWhere` methods from the `ScopedValue` class, leaving the API completely `ScopedValue.Carrier.call` and `ScopedValue.Carrier.run` methods.\n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/487#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "ScopedValue should be declared as static final",
              "rule_idea": "ScopedValue instances should be declared as static final fields to ensure they are shared across all instances of a class and cannot be reassigned. This follows the intended usage pattern for ScopedValues as immutable context carriers.",
              "code_examples": [
                {
                  "non_compliant": "public class UserService {\n    private ScopedValue<String> user = ScopedValue.newInstance(); // Not static final\n    \n    public void processUser() {\n        ScopedValue.where(user, \"Alice\").run(() -> {\n            System.out.println(\"User: \" + user.get());\n        });\n    }\n}",
                  "compliant": "public class UserService {\n    private static final ScopedValue<String> USER = ScopedValue.newInstance();\n    \n    public void processUser() {\n        ScopedValue.where(USER, \"Alice\").run(() -> {\n            System.out.println(\"User: \" + USER.get());\n        });\n    }\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://www.baeldung.com/java-25-features",
                  "source_text": "## 1. Overview[](https://www.baeldung.com/java-25-features#overview)\nJava 25 is almost out! The new long-term-support(LTS) release, scheduled for September 2025, introduces a comprehensive set of enhancements across the Java language, standard libraries, APIs, and runtime.\nIn this tutorial, we\u2019ll explore all the new features and changes introduced in Java 25 as of June 2025. Let\u2019s understand them with a simple code sample and a detailed explanation.\n## 2. Language and Compiler Features[](https://www.baeldung.com/java-25-features#language-and-compiler-features)\nJava 25 introduces a set of language and compiler enhancements aimed at making the language more expressive and concise. These features enhance the developer experience in both everyday tasks and advanced, modular scenarios.\n### 2.1. Primitive Types in Patterns (JEP 507 \u2013 Third Preview)[](https://www.baeldung.com/java-25-features#1-primitive-types-in-patterns-jep-507--third-preview)\nNow, pattern matching can handle primitive types in _switch_ and _instanceof_ statements. For instance:\n```\nstatic void test(Object obj) {\n    if (obj instanceof int i) {\n        System.out.println(\"It's an int: \" + i);\n    }\n}Copy\n```\n\nJEP 507 introduces primitive types into Java\u2019s pattern-matching framework, making such expressions more straightforward and reducing boilerplate code. This JEP is part of a broader effort to unify type patterns across the language.\n### 2.2. Module Import Declarations (JEP 511 \u2013 Preview)[](https://www.baeldung.com/java-25-features#2-module-import-declarations-jep-511--preview)\nJEP 511 introduces Module Import Declarations, allowing us to use modules to declare their dependencies via _import_ statements, improving modular readability. Traditionally, dependencies in a module were only declared in the _module-info.java_ descriptor using _requires_ directives.**JEP 511 introduces a way to declare module dependencies using the _import module_ statement at the top of a Java file, similar to traditional _import_ statements**. This enhances clarity and enables tools to infer dependencies during development with greater accuracy. For instance:\n```\nimport module java.base; \n//...\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = new Date();\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nHowever, we must be careful with ambiguous references. Let\u2019s see a sample code to demonstrate it:\n```\nimport module java.base;      // exports java.util, which includes java.util.Date\nimport module java.sql;       // exports java.sql, which also includes java.sql.Date\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = Date.valueOf(\"2025-06-15\");\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nWhen trying to compile this class, the following message will appear:\n```\nerror: reference to Date is ambiguous\n         Date d = Date.valueOf(\"2025-06-15\");\n         ^\n   both class java.sql.Date in java.sql and class java.util.Date in java.util match\n   error: reference to Date is ambiguousCopy\n```\n\nThe solution for this would be to add the import of the specific class that we want to use in this case:\n```\nimport module java.base;\nimport module java.sql;\n\nimport java.sql.Date;\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = Date.valueOf(\"2025-06-15\");\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nFinally, this change also allows us to switch from star imports to module imports:\n```\n// These imports could be coalesced:\nimport javax.xml.*; \nimport javax.xml.parsers.*; \nimport javax.xml.stream.*;\nCopy\n```\n\nInstead, just use:\n```\nimport module java.xml;Copy\n```\n\nAlthough it is not recommended to abuse both import star and module imports, it does make the import and dependency definition more concise and less verbose.\n### 2.3. Compact Source Files (JEP 512) and Instance Main Methods[](https://www.baeldung.com/java-25-features#3-compact-source-files-jep-512-and-instance-main-methods)\nNow Java supports top-level instance _main_ methods and class-less compact files. That means now the following declaration is valid:\n```\nvoid main() {\n    System.out.println(\"Hello from Java 25!\");\n}Copy\n```\n\nJEP 512 builds on the simplified launcher introduced in Java 21. It allows us to write quick scripts or demos without class declarations. **These compact source files are ideal for teaching, scripting, and rapid prototyping, lowering the barrier to entry for new developers and reducing the learning curve**.\n### 2.4. Flexible Constructor Bodies (JEP 513 \u2013 Final)[](https://www.baeldung.com/java-25-features#4-flexible-constructor-bodies-jep-513--final)\nFlexible Constructor Bodies (JEP 513) enables multiple constructors to delegate to a common initialization body, making it as simple as that:\n```\nclass Person {\n    final int age;\n\n    Person(int age) {\n        this.age = age;\n    }\n}\n\nclass Employee extends Person {\n    final String name;\n\n    Employee(String name, int age) {\n        if (age < 18 || age > 67)\n            throw new IllegalArgumentException(\"Age must be between 18 and 67\");\n        super(age); // super() is no longer required as the first statement in Java 25\n        this.name = name;\n    }\n\n    public static void main(String[] args) {\n        var emp = new Employee(\"Alice\", 35);\n        System.out.println(\"Person age set: \" + emp.age);\n    }\n}\nCopy\n```\n\nBefore JEP 513, Java constructors were required to invoke _super(\u2026)_ or _this(\u2026)_ as the very first statement, which often forced us to duplicate validation or initialization logic, or push it into static helper methods. **With JEP 513, we can include code before the constructor invocation, allowing argument validation or shared setup to happen cleanly in one place, improving readability, fail-fast behavior, and object integrity without breaking Java\u2019s construction rules**.\n## 3. API Enhancements[](https://www.baeldung.com/java-25-features#api-enhancements)\nJava 25 also brings a set of improvements for the existing APIs, in addition to continuing work on new APIs that are still in preview, final, and early stages.\n### 3.1. Scoped Values (JEP 506 \u2013 Final)[](https://www.baeldung.com/java-25-features#1-scoped-values-jep-506--final)\nJEP 506 offers lightweight, immutable, thread-safe alternative to _ThreadLocal_. Those are designed to work in conjunction with Virtual Threads:\n```\nimport java.lang.ScopedValue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ScopedUserExample {\n    static final ScopedValue<String> USER = ScopedValue.newInstance();\n\n    public static void main(String[] args) {\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            executor.submit(() -> ScopedValue.where(USER, \"Alice\").run(() -> {\n                System.out.println(\"Thread: \" + Thread.currentThread());\n                System.out.println(\"User: \" + USER.get());\n            }));\n\n            executor.submit(() -> ScopedValue.where(USER, \"Bob\").run(() -> {\n                System.out.println(\"Thread: \" + Thread.currentThread());\n                System.out.println(\"User: \" + USER.get());\n            }));\n\n            // Optional delay to ensure output appears before main exits\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\nCopy\n```\n\nScoped Values are designed to pass context across call chains in a safe, performant, and immutable way. They work particularly well with virtual threads and structured concurrency, offering an efficient alternative to _ThreadLocal_ by avoiding memory leaks and synchronization overhead.\n**Note: When we use Scoped Value with Virtual Threads, the logic that accesses the scoped value must be wrapped inside the _ScopedValue.where(\u2026).run(\u2026)_ scope. Submitting a task to an executor within the scope is not enough. The task itself must be created inside the scope to retain the binding.**\n### 3.2. Structured Concurrency (JEP 505 \u2013 Fifth Preview)[](https://www.baeldung.com/java-25-features#2-structured-concurrency-jep-505--fifth-preview)\nJEP 505 aims to simplify concurrency by treating related threads as a single unit with proper lifecycle management. The fifth preview refines the API by replacing constructors and separate policy methods with a single static factory method: _StructuredTaskScope.open()_. This approach improves consistency and flexibility for defining custom join and error-handling behaviors. Next, we\u2019ll use the new syntax:\n```\nimport java.util.concurrent.StructuredTaskScope;\n\npublic class StructuredExample {\n    static String fetchUser() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return \"Alice\";\n    }\n\n    static String fetchOrder() {\n        try {\n            Thread.sleep(150);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return \"Order#42\";\n    }\n\n    public static void main(String[] args) throws Exception {\n        try (var scope = StructuredTaskScope.<String>open()) {\n            var userTask = scope.fork(() -> fetchUser());\n            var orderTask = scope.fork(() -> fetchOrder());\n\n            scope.join();\n\n            System.out.println(userTask.get() + \" - \" + orderTask.get());\n        }\n    }\n}\nCopy\n```\n\nStructured concurrency helps us manage multiple concurrent tasks that are logically correlated. It guarantees that child threads complete or are cancelled as a group, improving reliability and readability in multi-threaded applications.\n### 3.3. Stable Value API (JEP 502 \u2013 Preview)[](https://www.baeldung.com/java-25-features#3-stable-value-api-jep-502--preview)\nThe Stable Value API (JEP 502) extends the _Optional-_ like semantics to context-stable immutable values:\n```\nimport java.lang.StableValue;\n\npublic class StableExample {\n    public static void main(String[] args) {\n        // Create a new unset StableValue\n        var greeting = StableValue.<String>of();\n\n        String message = greeting.orElseSet(() -> \"Hello from StableValue!\");\n        System.out.println(message);\n    }\n}\nCopy\n```\n\nStable values offer an API for safely sharing immutable, context-stable values across threads or computations. They\u2019re handy in situations involving caching, lazy evaluation, or consistent reads within a stable scope, and integrate well with structured concurrency.\n### 3.4. PEM Encodings of Cryptographic Objects (JEP 470 \u2013 Preview)[](https://www.baeldung.com/java-25-features#4-pem-encodings-of-cryptographic-objects-jep-470--preview)\nJEP 470 adds support for reading and writing cryptographic keys and certificates in PEM format via standard APIs. The new API abstracts such operations, making them as simple as:\n```\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class PEMExample {\n    public static void main(String[] args) {\n      String pem = \"\"\"\n        -----BEGIN PUBLIC KEY-----\n        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgjDohS0RHP395oJxciVaeks9N\n        KNY5m9V1IkBBwYsMGyxskrW5sapgi9qlGSYOma9kkko1xlBs17qG8TTg38faxgGJ\n        sLT2BAmdVFwuWdRtzq6ONn2YPHYj5s5pqx6vU5baz58/STQXNIhn21QoPjXgQCnj\n        Pp0OxnacWeRSnAIOmQIDAQAB\n        -----END PUBLIC KEY-----\n        \"\"\";\n\n        try {\n            String base64 = pem.replaceAll(\"-----.*-----\", \"\").replaceAll(\"\\\\s\", \"\");\n            byte[] keyBytes = Base64.getDecoder().decode(base64);\n\n            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);\n            KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n            PublicKey key = factory.generatePublic(spec);\n\n            System.out.println(\"Loaded key: \" + key.getAlgorithm());\n        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n    }\n}\nCopy\n```\n\nNow we can utilize the Java Security API to handle PEM-encoded objects, such as X.509 certificates and RSA keys, directly, eliminating the need for third-party libraries or manual conversions. This improves interoperability with OpenSSL-based systems and streamlines secure communications.\n### 3.5. Vector API (JEP 508 \u2013 Tenth Incubator)[](https://www.baeldung.com/java-25-features#5-vector-api-jep-508--tenth-incubator)\nJEP 508 provides an API to express vector computations that reliably compile to optimal vector hardware instructions:\n```\nimport jdk.incubator.vector.*;\n\npublic class VectorExample {\n    public static void main(String[] args) {\n        float[] left = {1f, 2f, 3f, 4f};\n        float[] right = {5f, 6f, 7f, 8f};\n\n        FloatVector a = FloatVector.fromArray(FloatVector.SPECIES_128, left, 0);\n        FloatVector b = FloatVector.fromArray(FloatVector.SPECIES_128, right, 0);\n        FloatVector c = a.add(b);\n\n        float[] result = new float[FloatVector.SPECIES_128.length()];\n        c.intoArray(result, 0);\n\n        System.out.println(\"Vector result: \" + java.util.Arrays.toString(result));\n    }\n}Copy\n```\n\n**Requires:_\u2013enable-preview \u2013add-modules jdk.incubator.vector_**\nThe Vector API enables data-parallel computations that can be executed efficiently on modern central processing units (CPUs). It helps Java code achieve performance comparable to hand-tuned native code by utilizing SIMD instructions, and continues to evolve through incubator stages.\n### 3.6. Key Derivation Function API (JEP 510 \u2013 Final)[](https://www.baeldung.com/java-25-features#6-key-derivation-function-api-jep-510--final)\nJava 25 introduces a standard API for password-based key derivation functions, such as PBKDF2 and scrypt:\n```\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\npublic class KeyDerivationExample {\n    public static void main(String[] args) throws Exception {\n        char[] password = \"hunter2\".toCharArray();\n        byte[] salt = \"somesalt\".getBytes();\n        PBEKeySpec spec = new PBEKeySpec(password, salt, 65536, 256);\n\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        SecretKey key = factory.generateSecret(spec);\n\n        System.out.println(\"Derived key format: \" + key.getFormat());\n    }\n}\nCopy\n```\n\nJEP 510 standardizes access to widely used cryptographic primitives for deriving encryption keys from user passwords, reducing reliance on third-party libraries and enabling secure implementations out of the box.\n## 4. Other Changes[](https://www.baeldung.com/java-25-features#other-changes)\nJava 25 changes also include the removal of configurations, platform-based updates, and enhancements.\n### 4.1. Remove the 32-bit x86 Port (JEP 503 \u2013 Final)[](https://www.baeldung.com/java-25-features#1-remove-the-32-bit-x86-port-jep-503--final)\nJEP 503 removes the support for the legacy 32-bit x86 architecture from OpenJDK. This JEP eliminates maintenance overhead for a platform with dwindling relevance. The 64-bit x86 and ARM64 ports remain fully supported.\n### 4.2. JFR CPU-Time Profiling (JEP 509 \u2013 Experimental)[](https://www.baeldung.com/java-25-features#2-jfr-cpu-time-profiling-jep-509--experimental)\nJEP 509 adds CPU-time-based profiling support to Java Flight Recorder (JFR). This feature enables us to record and analyze the amount of CPU time spent in specific methods or threads, thereby improving performance diagnostics, particularly in multi-threaded and I/O-bound workloads. Use the new _JDK.CPULoad_ and related JFR events with custom recordings:\n```\njava\n  -XX:StartFlightRecording=filename=cpu-time.jfr,duration=10s,settings=profile\n  --enable-preview\n  MyApp>Copy\n```\n\nThen analyze the _CPU time.JFR_ file in JDK Mission Control or VisualVM to observe CPU usage per method and thread.\n### 4.3. Ahead-of-Time Command-Line Ergonomics (JEP 514 \u2013 Final)[](https://www.baeldung.com/java-25-features#3-ahead-of-time-command-line-ergonomics-jep-514--final)\nJEP 514 is part of Project Leyden and introduces new JVM command-line flags (_-XX:AOTCacheOutput= <file>_) that disable dynamic features (like class loading and reflection) to evaluate how well an application could perform in a constrained runtime environment. These flags help us identify problematic code paths that would hinder static image generation or future ahead-of-time (AOT) compilation.\nWhile Java 25 does not yet provide a built-in AOT compiler, this JEP lays the groundwork by enabling early experimentation. It supports the long-term goal of delivering static Java applications with predictable startup performance and low memory footprint.\n### 4.4. Ahead-of-Time Method Profiling (JEP 515 \u2013 Final)[](https://www.baeldung.com/java-25-features#4-ahead-of-time-method-profiling-jep-515--final)\nJEP 515 introduces method-level profiling that records which methods are called and how often, along with other execution characteristics. This data can be saved and reused to inform future optimizations, such as ahead-of-time (AOT) compilation. While Java 25 does not yet include an AOT compiler, this JEP lays critical groundwork for improving startup performance in future versions by enabling profile-guided optimizations.\n### 4.5. JFR Cooperative Sampling (JEP 518 \u2013 Final)[](https://www.baeldung.com/java-25-features#5-jfr-cooperative-sampling-jep-518--final)\nJEP 518 allows applications to suggest safe sampling points to Java Flight Recorder. Cooperative sampling reduces overhead by aligning sampling with application-defined safe points, improving accuracy while minimizing disruption to performance-sensitive code.\n### 4.6. Compact Object Headers (JEP 519 \u2013 Final)[](https://www.baeldung.com/java-25-features#6-compact-object-headers-jep-519--final)\nJEP 519 reduces object header size on 64-bit architectures. This change shrinks the memory footprint of Java objects by using compact layouts for synchronization and identity data in object headers. It particularly benefits large heaps and microservice environments.\n### 4.7. JFR Method Timing and Tracing (JEP 520 \u2013 Final)[](https://www.baeldung.com/java-25-features#7-jfr-method-timing-and-tracing-jep-520--final)\nJEP 520 improves observability by recording timing data for all method calls on a thread, not just sampled methods. This enables precise reconstruction of method call stacks and durations for time intervals, helping us analyze execution flow and concurrency behavior more thoroughly. It complements existing profiling features by offering richer, deterministic tracing data rather than probabilistic sampling.\n### 4.8. Generational Shenandoah (JEP 521 \u2013 Final)[](https://www.baeldung.com/java-25-features#8-generational-shenandoah-jep-521--final)\nJEP 521 adds generational support to the Shenandoah garbage collector. Generational GC improves throughput and pause time performance by optimizing young-generation collection separately from long-lived objects. It brings Shenandoah in line with collectors like G1 and ZGC in terms of efficiency.\n## 5. What Developers Need to Know[](https://www.baeldung.com/java-25-features#what-developers-need-to-know)\nAs we just saw, many features in Java 25 are still in preview or incubator stage. To compile and run the code using these features, we must enable them. We already did in preview code snippets, but it\u2019s worth understanding it better:\n  * _\u2013enable-preview_ : required for all preview features, otherwise compile errors will appear\n  * _\u2013add-modules_ _< name>_: required for incubating modules, such as the _jdk.incubator.vector_ we used earlier\n  * _\u2013release 25_ : recommended during compilation to target the Java 25 platform\n\n\n**Be aware that preview and incubator APIs may change or be removed in future version** s. We should avoid using them in production or stay up to date with the official JDK documentation and release notes to look out for bug fixes or problems. Having this in mind, to compile and run code with such features, we need:\n```\n# At compile time do\njavac --enable-preview --release 25 --add-modules jdk.incubator.vector MyClass.java\n\n# At runtime do\njava --enable-preview --add-modules jdk.incubator.vector MyAppCopy\n```\n\nThis way we hint the Java Virtual Machine (JVM) to allow the use of such features at compile and runtime.\n## 6. Conclusion[](https://www.baeldung.com/java-25-features#conclusion)\nJava 25 continues the platform\u2019s steady evolution toward modernization and efficiency. It refines many preview features, introduces new APIs, and improves performance at every level, from language syntax to runtime diagnostics and memory management.\nThis release also highlights Java\u2019s commitment to modern hardware, including profiling and additional features. Java 25 is the newer LTS release. It offers valuable advantages and new capabilities that make it worthwhile for us, as developers, to upgrade our applications, so that we can leverage the new features added since the last LTS version (Java 21). The complete list of changes in Java 25 is in the \n12 Comments \nOldest\nNewest\nView all comments\nView Comments \nLoad More Comments \n\n\nwpDiscuz\nInsert\n"
                }
              ],
              "related_rules": []
            }
          ]
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 1
      },
      "classification": "-",
      "action": " ",
      "index": 1,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Avoid calling ScopedValue.get() outside of bound scope",
      "rule_idea": "ScopedValue.get() should only be called within the dynamic scope established by ScopedValue.where().run() or similar binding methods. Calling get() outside of a bound scope will throw an exception and indicates incorrect usage.",
      "code_examples": [
        {
          "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void method() {\n    ScopedValue.where(VALUE, \"test\").run(() -> doWork());\n    String result = VALUE.get(); // Called outside bound scope\n}",
          "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void method() {\n    ScopedValue.where(VALUE, \"test\").run(() -> {\n        String result = VALUE.get(); // Called within bound scope\n        doWork(result);\n    });\n}"
        }
      ],
      "sources": [
        {
          "cluster_description": "Both rules address the identical issue of preventing ScopedValue.get() calls outside of their bound scope, with nearly identical descriptions and code examples.",
          "original_ideas": [
            {
              "rule_title": "Avoid calling ScopedValue.get() outside of bound scope",
              "rule_idea": "ScopedValue.get() should only be called within the dynamic scope established by ScopedValue.where().run(). Calling get() outside this scope will throw an exception.",
              "code_examples": [
                {
                  "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\nvoid method() {\n    ScopedValue.where(VALUE, \"test\").run(() -> doWork());\n    String result = VALUE.get(); // Called outside scope\n}",
                  "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\nvoid method() {\n    ScopedValue.where(VALUE, \"test\").run(() -> {\n        String result = VALUE.get(); // Called within scope\n        doWork(result);\n    });\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/446",
                  "source_text": "# JEP 446: Scoped Values (Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 21  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 429: Scoped Values (Incubator)](https://openjdk.org/jeps/429)  \n| [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \nReviewed by | Alan Bateman, Mark Reinhold  \nEndorsed by | Brian Goetz  \nCreated | 2023/03/16 16:01  \nUpdated | 2023/11/29 14:41  \nIssue | [8304357](https://bugs.openjdk.org/browse/JDK-8304357)  \n## Summary\nIntroduce _scoped values_ , values that may be safely and efficiently shared to methods without using method parameters. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is a [preview API](https://openjdk.org/jeps/12).\nIn effect, a scoped value is an _implicit method parameter_. It is \"as if\" every method in a sequence of calls has an additional, invisible, parameter. None of the methods declare this parameter and only the methods that have access to the scoped value object can access its value (the data). Scoped values make it possible to pass data securely from a caller to a faraway callee through a sequence of intermediate methods that do not declare a parameter for the data and have no access to the data.\n## History\nScoped Values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429). In JDK 21 this feature is no longer incubating; instead, it is a [preview API](https://openjdk.org/jeps/12).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Allow shared data to be immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing them as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may need to maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the context object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework wishes to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during re-design of the framework, adding it requires not only the immediate clients -- those user methods that directly call framework methods or those that are directly called by it -- to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method arguments. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Code in one thread automatically reads and writes its value, while code in another thread automatically reads and writes its own distinct instantiation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from different methods, and `private` so that it cannot be directly accessed by client (user) code.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`.\nThe framework declares a thread-local variable, `CONTEXT` (1). When`Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method argument: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct instantiation in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 425](https://openjdk.org/jeps/425)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating-system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived [non-pooled](https://openjdk.org/jeps/425#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between methods in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many methods.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Frameowrk {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, `bar` sees the `\"hello\"` binding. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 428](https://openjdk.org/jeps/428)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 428](https://openjdk.org/jeps/428#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/446#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of ScopedValues because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Avoid calling ScopedValue.get() outside of bound scope",
              "rule_idea": "ScopedValue.get() should only be called within the dynamic scope established by ScopedValue.where().run() or similar binding methods. Calling get() outside of a bound scope will throw an exception and indicates incorrect usage.",
              "code_examples": [
                {
                  "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void method() {\n    ScopedValue.where(VALUE, \"test\").run(() -> doWork());\n    String result = VALUE.get(); // Called outside bound scope\n}",
                  "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void method() {\n    ScopedValue.where(VALUE, \"test\").run(() -> {\n        String result = VALUE.get(); // Called within bound scope\n        doWork(result);\n    });\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/464",
                  "source_text": "# JEP 464: Scoped Values (Second Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 22  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 446: Scoped Values (Preview)](https://openjdk.org/jeps/446)  \n| [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2023/10/26 12:05  \nUpdated | 2025/02/25 16:32  \nIssue | [8318898](https://bugs.openjdk.org/browse/JDK-8318898)  \n## Summary\nIntroduce _scoped values_ , which enable managed sharing of immutable data both with child frames in the same thread, and with child threads. Scoped values are easier to reason about than thread-local variables and have lower space and time costs, especially when used in combination with [Virtual Threads](https://openjdk.org/jeps/444) and [Structured Concurrency](https://openjdk.org/jeps/462). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nScoped values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429) and became a preview API in JDK 21 via [JEP 446](https://openjdk.org/jeps/446). We here propose to re-preview the API in JDK 22, without change, in order to gain additional experience and feedback.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data is visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller can only be retrieved by legitimate callees.\n  * _Performance_ \u2014 Data can be efficiently shared across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a final static field and its accessibility is set to private, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. Although a thread-local variable solves the problem of sharing data private between a caller and an indirect callee this solution suffers from some drawbacks, which are described in more detail in the discussion that follows the example. In summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided.\nThe framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set()` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set()` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `final` `static` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(NAME, <value>)\n           .run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Framework {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 453](https://openjdk.org/jeps/453)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 453](https://openjdk.org/jeps/453#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/464#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, an instance of `java.text.SimpleDateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. Today, though, any code caching a `SimpleDateFormat` could move to using `DateTimeFormatter` because it can be stored in a `static final` field and shared between threads.\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the small subset described above. While this JEP only presents examples that use `ScopedValue<V>.where(V, <value>).run(aRunnable)`, there are more ways to bind a scoped value. For example, the API also provides a `Callable` version which returns a value and may also throw an `Exception`:\n```\ntry {\n        var result = ScopedValue.where(X, \"hello\").call(() -> bar());\n        catch (Exception e) {\n            handleFailure(e);\n        }\n        ...\n```\n\nAdditionally, there are abbreviated versions of the binding methods. For example, `ScopedValue<V>.runWhere(V, <value>, aRunnable)` is a short form of `ScopedValue<V>.where(V, <value>).run(aRunnable)`. While this short form is sometimes convenient, it only allows a single scoped value to be bound at a time.\nThe full scoped value API is to be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. Scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            }
          ]
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 2
      },
      "classification": "-",
      "action": " ",
      "index": 2,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "ScopedValue should have private or package-private access for internal data",
      "rule_idea": "ScopedValue fields containing internal framework or library data should be declared with private or package-private access to prevent external code from accessing or interfering with the internal context. Public scoped values can lead to security vulnerabilities, tight coupling, and violations of the capability-based security model.",
      "code_examples": [
        {
          "non_compliant": "public class Framework {\n    public static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();\n}",
          "compliant": "public class Framework {\n    private static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();\n}"
        },
        {
          "non_compliant": "public static final ScopedValue<InternalData> INTERNAL_STATE = ScopedValue.newInstance();",
          "compliant": "private static final ScopedValue<InternalData> INTERNAL_STATE = ScopedValue.newInstance();"
        }
      ],
      "sources": [
        {
          "cluster_description": "These rules are being merged because they all address the same fundamental security and encapsulation principle: ScopedValue instances used for internal framework data should have restricted access modifiers (private or package-private) rather than public access to prevent external interference and maintain proper encapsulation boundaries.",
          "original_ideas": [
            {
              "rule_title": "ScopedValue should have private access for internal framework data",
              "rule_idea": "ScopedValue fields containing internal framework or library data should be declared private to prevent external code from accessing or interfering with the internal context, following the capability-based security model.",
              "code_examples": [
                {
                  "non_compliant": "public static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();",
                  "compliant": "private static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/446",
                  "source_text": "# JEP 446: Scoped Values (Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 21  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 429: Scoped Values (Incubator)](https://openjdk.org/jeps/429)  \n| [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \nReviewed by | Alan Bateman, Mark Reinhold  \nEndorsed by | Brian Goetz  \nCreated | 2023/03/16 16:01  \nUpdated | 2023/11/29 14:41  \nIssue | [8304357](https://bugs.openjdk.org/browse/JDK-8304357)  \n## Summary\nIntroduce _scoped values_ , values that may be safely and efficiently shared to methods without using method parameters. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is a [preview API](https://openjdk.org/jeps/12).\nIn effect, a scoped value is an _implicit method parameter_. It is \"as if\" every method in a sequence of calls has an additional, invisible, parameter. None of the methods declare this parameter and only the methods that have access to the scoped value object can access its value (the data). Scoped values make it possible to pass data securely from a caller to a faraway callee through a sequence of intermediate methods that do not declare a parameter for the data and have no access to the data.\n## History\nScoped Values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429). In JDK 21 this feature is no longer incubating; instead, it is a [preview API](https://openjdk.org/jeps/12).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Allow shared data to be immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing them as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may need to maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the context object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework wishes to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during re-design of the framework, adding it requires not only the immediate clients -- those user methods that directly call framework methods or those that are directly called by it -- to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method arguments. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Code in one thread automatically reads and writes its value, while code in another thread automatically reads and writes its own distinct instantiation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from different methods, and `private` so that it cannot be directly accessed by client (user) code.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`.\nThe framework declares a thread-local variable, `CONTEXT` (1). When`Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method argument: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct instantiation in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 425](https://openjdk.org/jeps/425)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating-system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived [non-pooled](https://openjdk.org/jeps/425#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between methods in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many methods.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Frameowrk {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, `bar` sees the `\"hello\"` binding. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 428](https://openjdk.org/jeps/428)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 428](https://openjdk.org/jeps/428#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/446#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of ScopedValues because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Scoped values should have private access when used for internal framework communication",
              "rule_idea": "Scoped values used for internal framework communication should be declared with private access to prevent external code from interfering with the context.",
              "code_examples": [
                {
                  "non_compliant": "public static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();",
                  "compliant": "private static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();"
                }
              ],
              "sources": [
                {
                  "url": "https://bugs.openjdk.org/browse/JDK-8352695",
                  "source_text": "### Details\n  * ** Type: **\n  * **Resolution:** Delivered \n  * ** Priority: **\n  * ** Fix Version/s:  ** [25](https://bugs.openjdk.org/issues/?jql=project+%3D+JDK+AND+fixVersion+%3D+%2225%22 \"25 JDK 25\")\n  * ** Component/s: ** [core-libs](https://bugs.openjdk.org/issues/?jql=project+%3D+JDK+AND+component+%3D+core-libs \"core-libs \")\n  * ** Labels: **\n    * [jdk25-ptt-2025-05-15](https://bugs.openjdk.org/issues/?jql=labels+%3D+jdk25-ptt-2025-05-15 \"jdk25-ptt-2025-05-15\")\n    * [loom](https://bugs.openjdk.org/issues/?jql=labels+%3D+loom \"loom\")\n\n\n  * ** Author: **\nAndrew Haley & Andrew Dinn \n  * ** JEP Type: **\nFeature \n  * ** Exposure: **\nOpen \n  * ** Scope: **\nSE \n  * ** Discussion: **\nloom dash dev at openjdk dot org \n  * ** JEP Number: **\n506 \n\n\n### Description\n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 505](https://openjdk.org/jeps/505)).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22), [JEP 481](https://openjdk.org/jeps/481) (JDK 23), and [JEP 487](https://openjdk.org/jeps/487) (JDK 24).\nWe here propose to finalize the scoped values API in JDK 25, with one small change: The `ScopedValue.orElse` method no longer accepts `null` as its argument.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls. \nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service. \n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n\n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n  |\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`. \nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 505](https://openjdk.org/jeps/505)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 505](https://openjdk.org/jeps/505#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://bugs.openjdk.org/browse/JDK-8352695#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\n    try {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site: \n```\n    where(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nWe also experimented with a version of scoped-value binding that supports the `AutoCloseable` interface, and so could be used in a `try`-with-resources construct. We ultimately rejected that idea because it is impossible to guarantee correct operation when relying on user code to invoke the `close` method at the right time. Also, even if that method is invoked as designed, by a `try`-with-resources construct, the operation may immediately fail with a `StackOverflowError`, leaving the program in an inconsistent state. Integrity, even in the case of `StackOverflowError`, is more important than the convenience of `try`-with-resources. The functional interfaces used by the `run` and `call` methods in this API allow us to guarantee integrity while still being reasonably easy to use.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n### Attachments\n### Issue Links \n\nis blocked by\n    \n[JDK-8355022](https://bugs.openjdk.org/browse/JDK-8355022) Implement JEP 506: Scoped Values\n  * Resolved\n\n\n\nrelates to\n    \n[JDK-8338456](https://bugs.openjdk.org/browse/JDK-8338456) JEP 487: Scoped Values (Fourth Preview)\n  * Closed\n\n    \n[JDK-8355720](https://bugs.openjdk.org/browse/JDK-8355720) Implement JEP 506: Scoped Values\n  * Closed\n\n\n### Activity\n## [JDK-8352695] JEP 506: Scoped Values\n  * [All](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel)\n  * Comments\n  * [History](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel)\n  * [Activity](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab)\n\n\nThere are no comments yet on this issue. \n### People \n\nAssignee: \n\n\nReporter: \n\n\nOwner: \n     Andrew Haley \n\nReviewed By: \n    \nAlan Bateman \n\nEndorsed By: \n    \nPaul Sandoz \n\nVotes:\n     0 Vote for this issue \n\nWatchers:\n     8 Start watching this issue\n### Dates \n\nCreated: \n     2025-03-24 03:10 \n\nUpdated: \n     2025-06-06 06:57 \n\nResolved: \n     2025-06-06 06:57\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Scoped values should have private or package-private access",
              "rule_idea": "Scoped values should be declared with private or package-private access to prevent external code from accessing internal framework data. Public scoped values can lead to security vulnerabilities and tight coupling.",
              "code_examples": [
                {
                  "non_compliant": "public class Framework {\n    public static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();\n}",
                  "compliant": "public class Framework {\n    private static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/487",
                  "source_text": "# JEP 487: Scoped Values (Fourth Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 24  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \n| [JEP 506: Scoped Values](https://openjdk.org/jeps/506)  \nReviewed by | Alan Bateman, Brian Goetz  \nEndorsed by | Alan Bateman  \nCreated | 2024/08/15 16:18  \nUpdated | 2025/04/10 18:03  \nIssue | [8338456](https://bugs.openjdk.org/browse/JDK-8338456)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22) and [JEP 481](https://openjdk.org/jeps/481) (JDK 23).\nWe here propose to re-preview the API once more in JDK 24 in order to gain additional experience and feedback, with one further change:\n  * We removed the `callWhere` and `runWhere` methods from the `ScopedValue` class, leaving the API completely `ScopedValue.Carrier.call` and `ScopedValue.Carrier.run` methods.\n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/487#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            }
          ]
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 3
      },
      "classification": "-",
      "action": " ",
      "index": 3,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Properly manage ScopedValue lifecycle with binding and scope access",
      "rule_idea": "Scoped values must be bound using ScopedValue.where().run() or call() before access, and should only be accessed within the dynamic scope of their binding. Direct access without binding or access outside the binding scope will result in runtime exceptions and violates the bounded lifetime principle.",
      "code_examples": [
        {
          "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    // Missing binding\n    String value = VALUE.get(); // Will throw exception\n}",
          "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    ScopedValue.where(VALUE, \"hello\").run(() -> {\n        String value = VALUE.get(); // Properly bound\n        processValue(value);\n    });\n}"
        },
        {
          "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    ScopedValue.where(VALUE, \"hello\").run(() -> {\n        // binding active here\n    });\n    String value = VALUE.get(); // Outside scope - will throw\n}",
          "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    ScopedValue.where(VALUE, \"hello\").run(() -> {\n        String value = VALUE.get(); // Within scope\n        processValue(value);\n    });\n}"
        }
      ],
      "sources": [
        {
          "cluster_description": "These rules are being merged because they both address proper scoped value lifecycle management - ensuring values are bound before access and only accessed within their binding scope.",
          "original_ideas": [
            {
              "rule_title": "Always use ScopedValue.where().run() or call() to bind values",
              "rule_idea": "Scoped values must be bound using the proper API methods (where().run() or where().call()) to ensure bounded lifetime and proper cleanup. Direct access without binding will result in runtime exceptions.",
              "code_examples": [
                {
                  "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    // Missing binding\n    String value = VALUE.get(); // Will throw exception\n}",
                  "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    ScopedValue.where(VALUE, \"hello\").run(() -> {\n        String value = VALUE.get(); // Properly bound\n    });\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/487",
                  "source_text": "# JEP 487: Scoped Values (Fourth Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 24  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \n| [JEP 506: Scoped Values](https://openjdk.org/jeps/506)  \nReviewed by | Alan Bateman, Brian Goetz  \nEndorsed by | Alan Bateman  \nCreated | 2024/08/15 16:18  \nUpdated | 2025/04/10 18:03  \nIssue | [8338456](https://bugs.openjdk.org/browse/JDK-8338456)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22) and [JEP 481](https://openjdk.org/jeps/481) (JDK 23).\nWe here propose to re-preview the API once more in JDK 24 in order to gain additional experience and feedback, with one further change:\n  * We removed the `callWhere` and `runWhere` methods from the `ScopedValue` class, leaving the API completely `ScopedValue.Carrier.call` and `ScopedValue.Carrier.run` methods.\n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/487#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Do not access scoped values outside their binding scope",
              "rule_idea": "Scoped values should only be accessed within the dynamic scope of their binding (inside the run() or call() method). Accessing them outside this scope will throw exceptions and violates the bounded lifetime principle.",
              "code_examples": [
                {
                  "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    ScopedValue.where(VALUE, \"hello\").run(() -> {\n        // binding active here\n    });\n    String value = VALUE.get(); // Outside scope - will throw\n}",
                  "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void process() {\n    ScopedValue.where(VALUE, \"hello\").run(() -> {\n        String value = VALUE.get(); // Within scope\n        processValue(value);\n    });\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/487",
                  "source_text": "# JEP 487: Scoped Values (Fourth Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 24  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \n| [JEP 506: Scoped Values](https://openjdk.org/jeps/506)  \nReviewed by | Alan Bateman, Brian Goetz  \nEndorsed by | Alan Bateman  \nCreated | 2024/08/15 16:18  \nUpdated | 2025/04/10 18:03  \nIssue | [8338456](https://bugs.openjdk.org/browse/JDK-8338456)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22) and [JEP 481](https://openjdk.org/jeps/481) (JDK 23).\nWe here propose to re-preview the API once more in JDK 24 in order to gain additional experience and feedback, with one further change:\n  * We removed the `callWhere` and `runWhere` methods from the `ScopedValue` class, leaving the API completely `ScopedValue.Carrier.call` and `ScopedValue.Carrier.run` methods.\n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/487#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            }
          ]
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 4
      },
      "classification": "-",
      "action": " ",
      "index": 4,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "ScopedValue must be bound before access",
      "rule_idea": "ScopedValue instances must be properly bound using the where() method before attempting to access their values. Accessing an unbound ScopedValue will throw a NoSuchElementException at runtime. All ScopedValue.get() calls must occur within the scope of a ScopedValue.where(...).run(...) or ScopedValue.where(...).call(...) binding block to ensure the value is available.",
      "code_examples": [
        {
          "non_compliant": "private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();\n\npublic void processRequest() {\n    // Accessing without binding\n    String userId = USER_ID.get(); // May throw NoSuchElementException\n    processUser(userId);\n}",
          "compliant": "private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();\n\npublic void processRequest(String userId) {\n    // Properly binding before access\n    ScopedValue.where(USER_ID, userId).run(() -> {\n        String boundUserId = USER_ID.get();\n        processUser(boundUserId);\n    });\n}"
        },
        {
          "non_compliant": "static final ScopedValue<String> USER = ScopedValue.newInstance();\n\npublic void processUser() {\n    // Accessing scoped value outside of binding scope\n    String user = USER.get(); // Will throw exception\n    System.out.println(\"User: \" + user);\n}",
          "compliant": "static final ScopedValue<String> USER = ScopedValue.newInstance();\n\npublic void processUser() {\n    ScopedValue.where(USER, \"Alice\").run(() -> {\n        String user = USER.get(); // Properly accessed within scope\n        System.out.println(\"User: \" + user);\n    });\n}"
        }
      ],
      "sources": [
        {
          "cluster_description": "Rules about ensuring ScopedValue instances are properly bound using ScopedValue.where() before accessing their values to prevent runtime exceptions.",
          "original_ideas": [
            {
              "rule_title": "Ensure ScopedValue is properly bound before access",
              "rule_idea": "ScopedValue instances should be properly bound using the where() method before attempting to access their values. Accessing an unbound ScopedValue will throw a NoSuchElementException. This rule helps detect potential runtime errors by ensuring proper binding patterns.",
              "code_examples": [
                {
                  "non_compliant": "private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();\n\npublic void processRequest() {\n    // Accessing without binding\n    String userId = USER_ID.get(); // May throw NoSuchElementException\n    processUser(userId);\n}",
                  "compliant": "private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();\n\npublic void processRequest(String userId) {\n    // Properly binding before access\n    ScopedValue.where(USER_ID, userId).run(() -> {\n        String boundUserId = USER_ID.get();\n        processUser(boundUserId);\n    });\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://data.javaalmanac.io/v1/jdk/versions/25/apidiffs/24",
                  "source_text": "```\n{\"base\":{\"feature\":\"24\",\"vendor\":\"open\",\"version\":\"24.0.2+12-54\"},\"target\":{\"feature\":\"25\",\"vendor\":\"open\",\"version\":\"25+36-3489\"},\"deltas\":[{\"type\":\"module\",\"name\":\"java.base\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.io\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Console\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Console.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"print(Object)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"println()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"println(Object)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"readln()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"readln(String)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"}]},{\"type\":\"class\",\"name\":\"FilePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/FilePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"IO\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"class\",\"name\":\"OptionalDataException\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/OptionalDataException.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Reader\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"readAllAsString()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html#readAllAsString()\",\"csr\":\"JDK-8356909\"},{\"type\":\"method\",\"name\":\"readAllLines()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html#readAllLines()\",\"csr\":\"JDK-8356909\"}]},{\"type\":\"class\",\"name\":\"SerializablePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/SerializablePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile.attribute\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/attribute/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"UnknownAttribute\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/attribute/UnknownAttribute.html\",\"addedTags\":[\"implements CodeElement\"]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile.constantpool\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"ClassEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ClassEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(ClassDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ClassEntry.html#matches(java.lang.constant.ClassDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"MethodTypeEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/MethodTypeEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(MethodTypeDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/MethodTypeEntry.html#matches(java.lang.constant.MethodTypeDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"ModuleEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ModuleEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(ModuleDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ModuleEntry.html#matches(java.lang.constant.ModuleDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"PackageEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/PackageEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(PackageDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/PackageEntry.html#matches(java.lang.constant.PackageDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"StringEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/StringEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"equalsString(String)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/StringEntry.html#equalsString(java.lang.String)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"Utf8Entry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"isFieldType(ClassDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html#isFieldType(java.lang.constant.ClassDesc)\",\"csr\":\"JDK-8342210\"},{\"type\":\"method\",\"name\":\"isMethodType(MethodTypeDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html#isMethodType(java.lang.constant.MethodTypeDesc)\",\"csr\":\"JDK-8342210\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"ClassFile\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/ClassFile.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"JAVA_25_VERSION\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/ClassFile.html#JAVA_25_VERSION\",\"csr\":\"JDK-8343029\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.constant\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/constant/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DynamicCallSiteDesc\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/constant/DynamicCallSiteDesc.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.invoke\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"MethodHandleProxies\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandleProxies.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"MethodHandles\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandles.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.module\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/module/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ModuleDescriptor\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/module/ModuleDescriptor.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.reflect\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Modifier\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Modifier.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ReflectPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ReflectPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"enum\",\"name\":\"AccessFlag.Location\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"flags()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flags()\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flags(ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flags(java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flagsMask()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flagsMask()\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flagsMask(ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flagsMask(java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8347626\"}]},{\"type\":\"enum\",\"name\":\"AccessFlag\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"maskToAccessFlags(int, AccessFlag.Location, ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.html#maskToAccessFlags(int,java.lang.reflect.AccessFlag.Location,java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8297741\"}]},{\"type\":\"enum\",\"name\":\"ClassFileFormatVersion\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ClassFileFormatVersion.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"RELEASE_25\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ClassFileFormatVersion.html#RELEASE_25\",\"csr\":\"JDK-8343029\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.runtime\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ObjectMethods\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/ObjectMethods.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"SwitchBootstraps\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/SwitchBootstraps.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Boolean\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Boolean(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Boolean(boolean)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html#%3Cinit%3E(boolean)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Byte\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Byte(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Byte(byte)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html#%3Cinit%3E(byte)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Character\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Character.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Character(char)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Character.html#%3Cinit%3E(char)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Double\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Double(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Double(double)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html#%3Cinit%3E(double)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Float\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Float(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Float(double)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(double)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Float(float)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(float)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"IO\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/IO.html\",\"csr\":\"JDK-8353437\"},{\"type\":\"class\",\"name\":\"Integer\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Integer(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Integer(int)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html#%3Cinit%3E(int)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Long\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Long(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Long(long)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html#%3Cinit%3E(long)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Math\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"powExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#powExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"powExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#powExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(long,long)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedPowExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedPowExact(long,int)\",\"csr\":\"JDK-8356077\"}]},{\"type\":\"class\",\"name\":\"Package\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Package.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"RuntimePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/RuntimePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"Runtime\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Runtime.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ScopedValue.Carrier\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.Carrier.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"ScopedValue\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"Short\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Short(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Short(short)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html#%3Cinit%3E(short)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"StrictMath\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"powExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#powExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"powExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#powExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(long,long)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedPowExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedPowExact(long,int)\",\"csr\":\"JDK-8356077\"}]},{\"type\":\"interface\",\"name\":\"CharSequence\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/CharSequence.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getChars(int, int, char[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/CharSequence.html#getChars(int,int,char%5B%5D,int)\",\"csr\":\"JDK-8343111\"}]},{\"type\":\"interface\",\"name\":\"ScopedValue.CallableOp\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.CallableOp.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"StableValue\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html\",\"csr\":\"JDK-8342068\"}]},{\"type\":\"package\",\"name\":\"java.net\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HttpURLConnection\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/HttpURLConnection.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getPermission()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/HttpURLConnection.html#getPermission()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"InterfaceAddress\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/InterfaceAddress.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"NetPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/NetPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"URLConnection\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLConnection.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getPermission()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLConnection.html#getPermission()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"URLDecoder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLDecoder.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"URLEncoder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLEncoder.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"URLPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.nio.charset\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"CoderResult\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/CoderResult.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"CodingErrorAction\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/CodingErrorAction.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.nio.file\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LinkPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/LinkPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.nio\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"CharBuffer\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/CharBuffer.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getChars(int, int, char[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/CharBuffer.html#getChars(int,int,char%5B%5D,int)\",\"csr\":\"JDK-8343111\"}]}]},{\"type\":\"package\",\"name\":\"java.security.cert\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"X509CRL\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/X509CRL.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"X509Certificate\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/X509Certificate.html\",\"addedTags\":[\"implements DEREncodable\"]}]},{\"type\":\"package\",\"name\":\"java.security.spec\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"PKCS8EncodedKeySpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/PKCS8EncodedKeySpec.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"X509EncodedKeySpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html\",\"addedTags\":[\"implements DEREncodable\"]}]},{\"type\":\"package\",\"name\":\"java.security\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DrbgParameters\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DrbgParameters.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"KeyPair\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/KeyPair.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"PEMDecoder\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMDecoder.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"PEMEncoder\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMEncoder.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"PEMRecord\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMRecord.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"SecurityPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/SecurityPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"UnresolvedPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/UnresolvedPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"interface\",\"name\":\"AsymmetricKey\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/AsymmetricKey.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"interface\",\"name\":\"DEREncodable\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DEREncodable.html\",\"csr\":\"JDK-8329419\"}]},{\"type\":\"package\",\"name\":\"java.util.concurrent.locks\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LockSupport\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/LockSupport.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.util.concurrent\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Executors\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/Executors.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ForkJoinPool\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html\",\"addedTags\":[\"implements ScheduledExecutorService\"],\"deltas\":[{\"type\":\"method\",\"name\":\"cancelDelayedTasksOnShutdown()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#cancelDelayedTasksOnShutdown()\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"getDelayedTaskCount()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#getDelayedTaskCount()\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"schedule(Callable, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"schedule(Runnable, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"scheduleAtFixedRate(Runnable, long, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"scheduleWithFixedDelay(Runnable, long, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"submitWithTimeout(Callable, long, TimeUnit, Consumer)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#submitWithTimeout(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit,java.util.function.Consumer)\",\"csr\":\"JDK-8350493\"}]},{\"type\":\"class\",\"name\":\"StructuredTaskScope.FailedException\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.FailedException.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.ShutdownOnFailure\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.ShutdownOnSuccess\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.TimeoutException\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.TimeoutException.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Configuration\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Configuration.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Joiner\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Subtask\",\"status\":\"notmodified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"task()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"}]},{\"type\":\"interface\",\"name\":\"StructuredTaskScope\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html\",\"addedTags\":[\"abstract\",\"sealed\"],\"deltas\":[{\"type\":\"method\",\"name\":\"StructuredTaskScope()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"StructuredTaskScope(String, ThreadFactory)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"close()\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()\",\"addedTags\":[\"abstract\"]},{\"type\":\"method\",\"name\":\"ensureOwnerAndJoined()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"fork(Callable)\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)\",\"addedTags\":[\"abstract\"]},{\"type\":\"method\",\"name\":\"fork(Runnable)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.lang.Runnable)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"handleComplete(StructuredTaskScope.Subtask)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"isCancelled()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#isCancelled()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"isShutdown()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"join()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"join()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"joinUntil(Instant)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open(StructuredTaskScope.Joiner)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open(StructuredTaskScope.Joiner, Function)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner,java.util.function.Function)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"shutdown()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"toString()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"}]}]},{\"type\":\"package\",\"name\":\"java.util.zip\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Deflater\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Deflater.html\",\"addedTags\":[\"implements AutoCloseable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"close()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Deflater.html#close()\",\"csr\":\"JDK-8343768\"}]},{\"type\":\"class\",\"name\":\"Inflater\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Inflater.html\",\"addedTags\":[\"implements AutoCloseable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"close()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Inflater.html#close()\",\"csr\":\"JDK-8343768\"}]}]},{\"type\":\"package\",\"name\":\"java.util\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Base64\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Base64.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Collections\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Collections.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Currency\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Currency.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"availableCurrencies()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Currency.html#availableCurrencies()\",\"csr\":\"JDK-8347950\"}]},{\"type\":\"class\",\"name\":\"FormattableFlags\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/FormattableFlags.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"PropertyPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/PropertyPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"TimeZone\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"availableIDs()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html#availableIDs()\",\"csr\":\"JDK-8348325\"},{\"type\":\"method\",\"name\":\"availableIDs(int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html#availableIDs(int)\",\"csr\":\"JDK-8348325\"}]}]},{\"type\":\"package\",\"name\":\"javax.crypto.spec\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Builder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Builder.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Expand\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Expand.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.ExtractThenExpand\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.ExtractThenExpand.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Extract\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Extract.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"HKDFParameterSpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.html\",\"removedTags\":[\"preview\"]}]},{\"type\":\"package\",\"name\":\"javax.crypto\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"EncryptedPrivateKeyInfo\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html\",\"addedTags\":[\"implements DEREncodable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, Key, String, AlgorithmParameterSpec, Provider, SecureRandom)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,java.security.Key,java.lang.String,java.security.spec.AlgorithmParameterSpec,java.security.Provider,java.security.SecureRandom)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, char[])\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,char%5B%5D)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, char[], String, AlgorithmParameterSpec, Provider)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,char%5B%5D,java.lang.String,java.security.spec.AlgorithmParameterSpec,java.security.Provider)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"getKey(Key, Provider)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#getKey(java.security.Key,java.security.Provider)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"getKey(char[])\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#getKey(char%5B%5D)\",\"csr\":\"JDK-8329419\"}]},{\"type\":\"class\",\"name\":\"KDFSpi\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDFSpi.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"KDF\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDF.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"KDFParameters\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDFParameters.html\",\"removedTags\":[\"preview\"]}]},{\"type\":\"package\",\"name\":\"javax.net.ssl\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ExtendedSSLSession\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"exportKeyingMaterialData(String, byte[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html#exportKeyingMaterialData(java.lang.String,byte%5B%5D,int)\",\"csr\":\"JDK-8348370\"},{\"type\":\"method\",\"name\":\"exportKeyingMaterialKey(String, String, byte[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html#exportKeyingMaterialKey(java.lang.String,java.lang.String,byte%5B%5D,int)\",\"csr\":\"JDK-8348370\"}]},{\"type\":\"class\",\"name\":\"SSLPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/SSLPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.security.auth\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"AuthPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/AuthPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"PrivateCredentialPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/PrivateCredentialPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.compiler\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.lang.model\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/package-summary.html\",\"deltas\":[{\"type\":\"enum\",\"name\":\"SourceVersion\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/SourceVersion.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"RELEASE_25\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/SourceVersion.html#RELEASE_25\",\"csr\":\"JDK-8343000\"}]}]}]},{\"type\":\"module\",\"name\":\"java.desktop\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.sound\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/sound/package-summary.html\",\"csr\":\"JDK-8356200\"},{\"type\":\"package\",\"name\":\"javax.swing.plaf.basic\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/basic/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"BasicSliderUI\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/basic/BasicSliderUI.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"BasicSliderUI()\",\"status\":\"removed\",\"csr\":\"JDK-8345648\"}]}]},{\"type\":\"package\",\"name\":\"javax.swing.plaf.synth\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/synth/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"SynthLookAndFeel\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/synth/SynthLookAndFeel.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"load(URL)\",\"status\":\"removed\",\"csr\":\"JDK-8351238\"}]}]}]},{\"type\":\"module\",\"name\":\"java.logging\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.util.logging\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/java/util/logging/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LoggingPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/java/util/logging/LoggingPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.lang.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/java/lang/management/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ManagementPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/java/lang/management/ManagementPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management.modelmbean\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DescriptorSupport\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"DescriptorSupport(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html#%3Cinit%3E(java.lang.String)\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"method\",\"name\":\"toXMLString()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html#toXMLString()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"XMLParseException\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/XMLParseException.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management.remote\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/remote/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"SubjectDelegationPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/remote/SubjectDelegationPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"MBeanPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"MBeanServerPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanServerPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"MBeanTrustPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanTrustPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.net.http\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.net.http\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HttpResponse.BodyHandlers\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"limiting(HttpResponse.BodyHandler, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html#limiting(java.net.http.HttpResponse.BodyHandler,long)\",\"csr\":\"JDK-8347904\"}]},{\"type\":\"class\",\"name\":\"HttpResponse.BodySubscribers\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodySubscribers.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"limiting(HttpResponse.BodySubscriber, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodySubscribers.html#limiting(java.net.http.HttpResponse.BodySubscriber,long)\",\"csr\":\"JDK-8347904\"}]},{\"type\":\"interface\",\"name\":\"HttpResponse\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"connectionLabel()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.html#connectionLabel()\",\"csr\":\"JDK-8352751\"}]}]}]},{\"type\":\"module\",\"name\":\"java.security.jgss\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.security.auth.kerberos\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DelegationPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/DelegationPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"ServicePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/ServicePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.xml.crypto\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.xml.crypto.dsig\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"SignatureMethod\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"ECDSA_SHA3_224\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_224\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_256\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_256\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_384\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_384\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_512\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_512\",\"csr\":\"JDK-8345411\"}]}]}]}]}\n```\n\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Scoped Value access must be within proper scope binding",
              "rule_idea": "When accessing a ScopedValue, ensure that the access occurs within a ScopedValue.where(...).run(...) or ScopedValue.where(...).call(...) scope binding. Accessing a ScopedValue outside of its binding scope will result in a runtime exception.",
              "code_examples": [
                {
                  "non_compliant": "static final ScopedValue<String> USER = ScopedValue.newInstance();\n\npublic void processUser() {\n    // Accessing scoped value outside of binding scope\n    String user = USER.get(); // Will throw exception\n    System.out.println(\"User: \" + user);\n}",
                  "compliant": "static final ScopedValue<String> USER = ScopedValue.newInstance();\n\npublic void processUser() {\n    ScopedValue.where(USER, \"Alice\").run(() -> {\n        String user = USER.get(); // Properly accessed within scope\n        System.out.println(\"User: \" + user);\n    });\n}"
                }
              ],
              "sources": [
                {
                  "url": "https://www.baeldung.com/java-25-features",
                  "source_text": "## 1. Overview[](https://www.baeldung.com/java-25-features#overview)\nJava 25 is almost out! The new long-term-support(LTS) release, scheduled for September 2025, introduces a comprehensive set of enhancements across the Java language, standard libraries, APIs, and runtime.\nIn this tutorial, we\u2019ll explore all the new features and changes introduced in Java 25 as of June 2025. Let\u2019s understand them with a simple code sample and a detailed explanation.\n## 2. Language and Compiler Features[](https://www.baeldung.com/java-25-features#language-and-compiler-features)\nJava 25 introduces a set of language and compiler enhancements aimed at making the language more expressive and concise. These features enhance the developer experience in both everyday tasks and advanced, modular scenarios.\n### 2.1. Primitive Types in Patterns (JEP 507 \u2013 Third Preview)[](https://www.baeldung.com/java-25-features#1-primitive-types-in-patterns-jep-507--third-preview)\nNow, pattern matching can handle primitive types in _switch_ and _instanceof_ statements. For instance:\n```\nstatic void test(Object obj) {\n    if (obj instanceof int i) {\n        System.out.println(\"It's an int: \" + i);\n    }\n}Copy\n```\n\nJEP 507 introduces primitive types into Java\u2019s pattern-matching framework, making such expressions more straightforward and reducing boilerplate code. This JEP is part of a broader effort to unify type patterns across the language.\n### 2.2. Module Import Declarations (JEP 511 \u2013 Preview)[](https://www.baeldung.com/java-25-features#2-module-import-declarations-jep-511--preview)\nJEP 511 introduces Module Import Declarations, allowing us to use modules to declare their dependencies via _import_ statements, improving modular readability. Traditionally, dependencies in a module were only declared in the _module-info.java_ descriptor using _requires_ directives.**JEP 511 introduces a way to declare module dependencies using the _import module_ statement at the top of a Java file, similar to traditional _import_ statements**. This enhances clarity and enables tools to infer dependencies during development with greater accuracy. For instance:\n```\nimport module java.base; \n//...\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = new Date();\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nHowever, we must be careful with ambiguous references. Let\u2019s see a sample code to demonstrate it:\n```\nimport module java.base;      // exports java.util, which includes java.util.Date\nimport module java.sql;       // exports java.sql, which also includes java.sql.Date\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = Date.valueOf(\"2025-06-15\");\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nWhen trying to compile this class, the following message will appear:\n```\nerror: reference to Date is ambiguous\n         Date d = Date.valueOf(\"2025-06-15\");\n         ^\n   both class java.sql.Date in java.sql and class java.util.Date in java.util match\n   error: reference to Date is ambiguousCopy\n```\n\nThe solution for this would be to add the import of the specific class that we want to use in this case:\n```\nimport module java.base;\nimport module java.sql;\n\nimport java.sql.Date;\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = Date.valueOf(\"2025-06-15\");\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nFinally, this change also allows us to switch from star imports to module imports:\n```\n// These imports could be coalesced:\nimport javax.xml.*; \nimport javax.xml.parsers.*; \nimport javax.xml.stream.*;\nCopy\n```\n\nInstead, just use:\n```\nimport module java.xml;Copy\n```\n\nAlthough it is not recommended to abuse both import star and module imports, it does make the import and dependency definition more concise and less verbose.\n### 2.3. Compact Source Files (JEP 512) and Instance Main Methods[](https://www.baeldung.com/java-25-features#3-compact-source-files-jep-512-and-instance-main-methods)\nNow Java supports top-level instance _main_ methods and class-less compact files. That means now the following declaration is valid:\n```\nvoid main() {\n    System.out.println(\"Hello from Java 25!\");\n}Copy\n```\n\nJEP 512 builds on the simplified launcher introduced in Java 21. It allows us to write quick scripts or demos without class declarations. **These compact source files are ideal for teaching, scripting, and rapid prototyping, lowering the barrier to entry for new developers and reducing the learning curve**.\n### 2.4. Flexible Constructor Bodies (JEP 513 \u2013 Final)[](https://www.baeldung.com/java-25-features#4-flexible-constructor-bodies-jep-513--final)\nFlexible Constructor Bodies (JEP 513) enables multiple constructors to delegate to a common initialization body, making it as simple as that:\n```\nclass Person {\n    final int age;\n\n    Person(int age) {\n        this.age = age;\n    }\n}\n\nclass Employee extends Person {\n    final String name;\n\n    Employee(String name, int age) {\n        if (age < 18 || age > 67)\n            throw new IllegalArgumentException(\"Age must be between 18 and 67\");\n        super(age); // super() is no longer required as the first statement in Java 25\n        this.name = name;\n    }\n\n    public static void main(String[] args) {\n        var emp = new Employee(\"Alice\", 35);\n        System.out.println(\"Person age set: \" + emp.age);\n    }\n}\nCopy\n```\n\nBefore JEP 513, Java constructors were required to invoke _super(\u2026)_ or _this(\u2026)_ as the very first statement, which often forced us to duplicate validation or initialization logic, or push it into static helper methods. **With JEP 513, we can include code before the constructor invocation, allowing argument validation or shared setup to happen cleanly in one place, improving readability, fail-fast behavior, and object integrity without breaking Java\u2019s construction rules**.\n## 3. API Enhancements[](https://www.baeldung.com/java-25-features#api-enhancements)\nJava 25 also brings a set of improvements for the existing APIs, in addition to continuing work on new APIs that are still in preview, final, and early stages.\n### 3.1. Scoped Values (JEP 506 \u2013 Final)[](https://www.baeldung.com/java-25-features#1-scoped-values-jep-506--final)\nJEP 506 offers lightweight, immutable, thread-safe alternative to _ThreadLocal_. Those are designed to work in conjunction with Virtual Threads:\n```\nimport java.lang.ScopedValue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ScopedUserExample {\n    static final ScopedValue<String> USER = ScopedValue.newInstance();\n\n    public static void main(String[] args) {\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            executor.submit(() -> ScopedValue.where(USER, \"Alice\").run(() -> {\n                System.out.println(\"Thread: \" + Thread.currentThread());\n                System.out.println(\"User: \" + USER.get());\n            }));\n\n            executor.submit(() -> ScopedValue.where(USER, \"Bob\").run(() -> {\n                System.out.println(\"Thread: \" + Thread.currentThread());\n                System.out.println(\"User: \" + USER.get());\n            }));\n\n            // Optional delay to ensure output appears before main exits\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\nCopy\n```\n\nScoped Values are designed to pass context across call chains in a safe, performant, and immutable way. They work particularly well with virtual threads and structured concurrency, offering an efficient alternative to _ThreadLocal_ by avoiding memory leaks and synchronization overhead.\n**Note: When we use Scoped Value with Virtual Threads, the logic that accesses the scoped value must be wrapped inside the _ScopedValue.where(\u2026).run(\u2026)_ scope. Submitting a task to an executor within the scope is not enough. The task itself must be created inside the scope to retain the binding.**\n### 3.2. Structured Concurrency (JEP 505 \u2013 Fifth Preview)[](https://www.baeldung.com/java-25-features#2-structured-concurrency-jep-505--fifth-preview)\nJEP 505 aims to simplify concurrency by treating related threads as a single unit with proper lifecycle management. The fifth preview refines the API by replacing constructors and separate policy methods with a single static factory method: _StructuredTaskScope.open()_. This approach improves consistency and flexibility for defining custom join and error-handling behaviors. Next, we\u2019ll use the new syntax:\n```\nimport java.util.concurrent.StructuredTaskScope;\n\npublic class StructuredExample {\n    static String fetchUser() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return \"Alice\";\n    }\n\n    static String fetchOrder() {\n        try {\n            Thread.sleep(150);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return \"Order#42\";\n    }\n\n    public static void main(String[] args) throws Exception {\n        try (var scope = StructuredTaskScope.<String>open()) {\n            var userTask = scope.fork(() -> fetchUser());\n            var orderTask = scope.fork(() -> fetchOrder());\n\n            scope.join();\n\n            System.out.println(userTask.get() + \" - \" + orderTask.get());\n        }\n    }\n}\nCopy\n```\n\nStructured concurrency helps us manage multiple concurrent tasks that are logically correlated. It guarantees that child threads complete or are cancelled as a group, improving reliability and readability in multi-threaded applications.\n### 3.3. Stable Value API (JEP 502 \u2013 Preview)[](https://www.baeldung.com/java-25-features#3-stable-value-api-jep-502--preview)\nThe Stable Value API (JEP 502) extends the _Optional-_ like semantics to context-stable immutable values:\n```\nimport java.lang.StableValue;\n\npublic class StableExample {\n    public static void main(String[] args) {\n        // Create a new unset StableValue\n        var greeting = StableValue.<String>of();\n\n        String message = greeting.orElseSet(() -> \"Hello from StableValue!\");\n        System.out.println(message);\n    }\n}\nCopy\n```\n\nStable values offer an API for safely sharing immutable, context-stable values across threads or computations. They\u2019re handy in situations involving caching, lazy evaluation, or consistent reads within a stable scope, and integrate well with structured concurrency.\n### 3.4. PEM Encodings of Cryptographic Objects (JEP 470 \u2013 Preview)[](https://www.baeldung.com/java-25-features#4-pem-encodings-of-cryptographic-objects-jep-470--preview)\nJEP 470 adds support for reading and writing cryptographic keys and certificates in PEM format via standard APIs. The new API abstracts such operations, making them as simple as:\n```\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class PEMExample {\n    public static void main(String[] args) {\n      String pem = \"\"\"\n        -----BEGIN PUBLIC KEY-----\n        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgjDohS0RHP395oJxciVaeks9N\n        KNY5m9V1IkBBwYsMGyxskrW5sapgi9qlGSYOma9kkko1xlBs17qG8TTg38faxgGJ\n        sLT2BAmdVFwuWdRtzq6ONn2YPHYj5s5pqx6vU5baz58/STQXNIhn21QoPjXgQCnj\n        Pp0OxnacWeRSnAIOmQIDAQAB\n        -----END PUBLIC KEY-----\n        \"\"\";\n\n        try {\n            String base64 = pem.replaceAll(\"-----.*-----\", \"\").replaceAll(\"\\\\s\", \"\");\n            byte[] keyBytes = Base64.getDecoder().decode(base64);\n\n            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);\n            KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n            PublicKey key = factory.generatePublic(spec);\n\n            System.out.println(\"Loaded key: \" + key.getAlgorithm());\n        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n    }\n}\nCopy\n```\n\nNow we can utilize the Java Security API to handle PEM-encoded objects, such as X.509 certificates and RSA keys, directly, eliminating the need for third-party libraries or manual conversions. This improves interoperability with OpenSSL-based systems and streamlines secure communications.\n### 3.5. Vector API (JEP 508 \u2013 Tenth Incubator)[](https://www.baeldung.com/java-25-features#5-vector-api-jep-508--tenth-incubator)\nJEP 508 provides an API to express vector computations that reliably compile to optimal vector hardware instructions:\n```\nimport jdk.incubator.vector.*;\n\npublic class VectorExample {\n    public static void main(String[] args) {\n        float[] left = {1f, 2f, 3f, 4f};\n        float[] right = {5f, 6f, 7f, 8f};\n\n        FloatVector a = FloatVector.fromArray(FloatVector.SPECIES_128, left, 0);\n        FloatVector b = FloatVector.fromArray(FloatVector.SPECIES_128, right, 0);\n        FloatVector c = a.add(b);\n\n        float[] result = new float[FloatVector.SPECIES_128.length()];\n        c.intoArray(result, 0);\n\n        System.out.println(\"Vector result: \" + java.util.Arrays.toString(result));\n    }\n}Copy\n```\n\n**Requires:_\u2013enable-preview \u2013add-modules jdk.incubator.vector_**\nThe Vector API enables data-parallel computations that can be executed efficiently on modern central processing units (CPUs). It helps Java code achieve performance comparable to hand-tuned native code by utilizing SIMD instructions, and continues to evolve through incubator stages.\n### 3.6. Key Derivation Function API (JEP 510 \u2013 Final)[](https://www.baeldung.com/java-25-features#6-key-derivation-function-api-jep-510--final)\nJava 25 introduces a standard API for password-based key derivation functions, such as PBKDF2 and scrypt:\n```\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\npublic class KeyDerivationExample {\n    public static void main(String[] args) throws Exception {\n        char[] password = \"hunter2\".toCharArray();\n        byte[] salt = \"somesalt\".getBytes();\n        PBEKeySpec spec = new PBEKeySpec(password, salt, 65536, 256);\n\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        SecretKey key = factory.generateSecret(spec);\n\n        System.out.println(\"Derived key format: \" + key.getFormat());\n    }\n}\nCopy\n```\n\nJEP 510 standardizes access to widely used cryptographic primitives for deriving encryption keys from user passwords, reducing reliance on third-party libraries and enabling secure implementations out of the box.\n## 4. Other Changes[](https://www.baeldung.com/java-25-features#other-changes)\nJava 25 changes also include the removal of configurations, platform-based updates, and enhancements.\n### 4.1. Remove the 32-bit x86 Port (JEP 503 \u2013 Final)[](https://www.baeldung.com/java-25-features#1-remove-the-32-bit-x86-port-jep-503--final)\nJEP 503 removes the support for the legacy 32-bit x86 architecture from OpenJDK. This JEP eliminates maintenance overhead for a platform with dwindling relevance. The 64-bit x86 and ARM64 ports remain fully supported.\n### 4.2. JFR CPU-Time Profiling (JEP 509 \u2013 Experimental)[](https://www.baeldung.com/java-25-features#2-jfr-cpu-time-profiling-jep-509--experimental)\nJEP 509 adds CPU-time-based profiling support to Java Flight Recorder (JFR). This feature enables us to record and analyze the amount of CPU time spent in specific methods or threads, thereby improving performance diagnostics, particularly in multi-threaded and I/O-bound workloads. Use the new _JDK.CPULoad_ and related JFR events with custom recordings:\n```\njava\n  -XX:StartFlightRecording=filename=cpu-time.jfr,duration=10s,settings=profile\n  --enable-preview\n  MyApp>Copy\n```\n\nThen analyze the _CPU time.JFR_ file in JDK Mission Control or VisualVM to observe CPU usage per method and thread.\n### 4.3. Ahead-of-Time Command-Line Ergonomics (JEP 514 \u2013 Final)[](https://www.baeldung.com/java-25-features#3-ahead-of-time-command-line-ergonomics-jep-514--final)\nJEP 514 is part of Project Leyden and introduces new JVM command-line flags (_-XX:AOTCacheOutput= <file>_) that disable dynamic features (like class loading and reflection) to evaluate how well an application could perform in a constrained runtime environment. These flags help us identify problematic code paths that would hinder static image generation or future ahead-of-time (AOT) compilation.\nWhile Java 25 does not yet provide a built-in AOT compiler, this JEP lays the groundwork by enabling early experimentation. It supports the long-term goal of delivering static Java applications with predictable startup performance and low memory footprint.\n### 4.4. Ahead-of-Time Method Profiling (JEP 515 \u2013 Final)[](https://www.baeldung.com/java-25-features#4-ahead-of-time-method-profiling-jep-515--final)\nJEP 515 introduces method-level profiling that records which methods are called and how often, along with other execution characteristics. This data can be saved and reused to inform future optimizations, such as ahead-of-time (AOT) compilation. While Java 25 does not yet include an AOT compiler, this JEP lays critical groundwork for improving startup performance in future versions by enabling profile-guided optimizations.\n### 4.5. JFR Cooperative Sampling (JEP 518 \u2013 Final)[](https://www.baeldung.com/java-25-features#5-jfr-cooperative-sampling-jep-518--final)\nJEP 518 allows applications to suggest safe sampling points to Java Flight Recorder. Cooperative sampling reduces overhead by aligning sampling with application-defined safe points, improving accuracy while minimizing disruption to performance-sensitive code.\n### 4.6. Compact Object Headers (JEP 519 \u2013 Final)[](https://www.baeldung.com/java-25-features#6-compact-object-headers-jep-519--final)\nJEP 519 reduces object header size on 64-bit architectures. This change shrinks the memory footprint of Java objects by using compact layouts for synchronization and identity data in object headers. It particularly benefits large heaps and microservice environments.\n### 4.7. JFR Method Timing and Tracing (JEP 520 \u2013 Final)[](https://www.baeldung.com/java-25-features#7-jfr-method-timing-and-tracing-jep-520--final)\nJEP 520 improves observability by recording timing data for all method calls on a thread, not just sampled methods. This enables precise reconstruction of method call stacks and durations for time intervals, helping us analyze execution flow and concurrency behavior more thoroughly. It complements existing profiling features by offering richer, deterministic tracing data rather than probabilistic sampling.\n### 4.8. Generational Shenandoah (JEP 521 \u2013 Final)[](https://www.baeldung.com/java-25-features#8-generational-shenandoah-jep-521--final)\nJEP 521 adds generational support to the Shenandoah garbage collector. Generational GC improves throughput and pause time performance by optimizing young-generation collection separately from long-lived objects. It brings Shenandoah in line with collectors like G1 and ZGC in terms of efficiency.\n## 5. What Developers Need to Know[](https://www.baeldung.com/java-25-features#what-developers-need-to-know)\nAs we just saw, many features in Java 25 are still in preview or incubator stage. To compile and run the code using these features, we must enable them. We already did in preview code snippets, but it\u2019s worth understanding it better:\n  * _\u2013enable-preview_ : required for all preview features, otherwise compile errors will appear\n  * _\u2013add-modules_ _< name>_: required for incubating modules, such as the _jdk.incubator.vector_ we used earlier\n  * _\u2013release 25_ : recommended during compilation to target the Java 25 platform\n\n\n**Be aware that preview and incubator APIs may change or be removed in future version** s. We should avoid using them in production or stay up to date with the official JDK documentation and release notes to look out for bug fixes or problems. Having this in mind, to compile and run code with such features, we need:\n```\n# At compile time do\njavac --enable-preview --release 25 --add-modules jdk.incubator.vector MyClass.java\n\n# At runtime do\njava --enable-preview --add-modules jdk.incubator.vector MyAppCopy\n```\n\nThis way we hint the Java Virtual Machine (JVM) to allow the use of such features at compile and runtime.\n## 6. Conclusion[](https://www.baeldung.com/java-25-features#conclusion)\nJava 25 continues the platform\u2019s steady evolution toward modernization and efficiency. It refines many preview features, introduces new APIs, and improves performance at every level, from language syntax to runtime diagnostics and memory management.\nThis release also highlights Java\u2019s commitment to modern hardware, including profiling and additional features. Java 25 is the newer LTS release. It offers valuable advantages and new capabilities that make it worthwhile for us, as developers, to upgrade our applications, so that we can leverage the new features added since the last LTS version (Java 21). The complete list of changes in Java 25 is in the \n12 Comments \nOldest\nNewest\nView all comments\nView Comments \nLoad More Comments \n\n\nwpDiscuz\nInsert\n"
                }
              ],
              "related_rules": []
            }
          ]
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 5
      },
      "classification": "-",
      "action": " ",
      "index": 5,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Avoid calling ScopedValue.get() outside of bound scope",
      "rule_idea": "ScopedValue.get() should only be called within the dynamic scope established by ScopedValue.where().run() or call(). Calling get() outside this scope will throw an exception and indicates incorrect usage.",
      "code_examples": [
        {
          "non_compliant": "void method() {\n    where(CONTEXT, value).run(() -> doWork());\n    var ctx = CONTEXT.get(); // Outside scope\n}",
          "compliant": "void method() {\n    where(CONTEXT, value).run(() -> {\n        var ctx = CONTEXT.get(); // Within scope\n        doWork(ctx);\n    });\n}"
        }
      ],
      "sources": [
        {
          "url": "https://openjdk.org/jeps/506",
          "source_text": "# JEP 506: Scoped Values\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 25  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2025/03/24 10:10  \nUpdated | 2025/06/06 13:57  \nIssue | [8352695](https://bugs.openjdk.org/browse/JDK-8352695)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 505](https://openjdk.org/jeps/505)).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22), [JEP 481](https://openjdk.org/jeps/481) (JDK 23), and [JEP 487](https://openjdk.org/jeps/487) (JDK 24).\nWe here propose to finalize the scoped values API in JDK 25, with one small change: The `ScopedValue.orElse` method no longer accepts `null` as its argument.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 505](https://openjdk.org/jeps/505)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 505](https://openjdk.org/jeps/505#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/506#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nWe also experimented with a version of scoped-value binding that supports the `AutoCloseable` interface, and so could be used in a `try`-with-resources construct. We ultimately rejected that idea because it is impossible to guarantee correct operation when relying on user code to invoke the `close` method at the right time. Also, even if that method is invoked as designed, by a `try`-with-resources construct, the operation may immediately fail with a `StackOverflowError`, leaving the program in an inconsistent state. Integrity, even in the case of `StackOverflowError`, is more important than the convenience of `try`-with-resources. The functional interfaces used by the `run` and `call` methods in this API allow us to guarantee integrity while still being reasonably easy to use.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 6
      },
      "classification": "-",
      "action": " ",
      "index": 6,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Declare ScopedValue as final static field",
      "rule_idea": "ScopedValue instances should be declared as final static fields to ensure they can be easily reached from many components and maintain their identity throughout the application lifecycle.",
      "code_examples": [
        {
          "non_compliant": "class Server {\n    private ScopedValue<Principal> principal = ScopedValue.newInstance(); // Not static\n    \n    void serve(Request request, Response response) {\n        ScopedValue.where(principal, new Principal())\n                   .run(() -> Application.handle(request, response));\n    }\n}",
          "compliant": "class Server {\n    final static ScopedValue<Principal> PRINCIPAL = ScopedValue.newInstance();\n    \n    void serve(Request request, Response response) {\n        ScopedValue.where(PRINCIPAL, new Principal())\n                   .run(() -> Application.handle(request, response));\n    }\n}"
        }
      ],
      "sources": [
        {
          "url": "https://openjdk.org/jeps/429",
          "source_text": "# JEP 429: Scoped Values (Incubator)\nAuthors | Andrew Haley, Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | JDK  \nStatus | Closed / Delivered  \nRelease | 20  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot java dot net  \nRelates to | [JEP 446: Scoped Values (Preview)](https://openjdk.org/jeps/446)  \nReviewed by | Alan Bateman, Alex Buckley  \nEndorsed by | John Rose  \nCreated | 2021/03/04 11:03  \nUpdated | 2023/11/29 14:40  \nIssue | [8263012](https://bugs.openjdk.org/browse/JDK-8263012)  \n## Summary\nIntroduce _scoped values_ , which enable the sharing of immutable data within and across threads. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is an [incubating API](https://openjdk.org/jeps/11).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Treat shared data as immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nLarge Java programs typically consist of distinct and complementary components that need to share data between themselves. For example, a web framework might include a server component, implemented in the `Principal` object shared between components. The server component creates a `Principal` for each thread that handles a request, and the data access component refers to a thread's `Principal` to control access to the database.\nThe diagram below shows the framework handling two requests, each in its own thread. Request handling flows upward, from the server component (`Server.serve(...)`) to user code (`Application.handle(...)`) to the data access component (`DBAccess.open()`). The data access component determines whether the thread is permitted to access the database, as follows:\n  * In Thread 1, the `ADMIN` principal created by the server component allows database access. The dashed line indicates the principal is to be shared with the data access component, which inspects it and proceeds to call `DBAccess.newConnection()`.\n  * In Thread 2, the `GUEST` principal created by the server component does not allow database access. The data access component inspects the principal, determines that the user code must not proceed, and throws an `InvalidPrincipalException`.\n\n\n```\nThread 1                                 Thread 2\n--------                                 --------\n8. DBAccess.newConnection()              8. throw new InvalidPrincipalException()\n7. DBAccess.open() <----------+          7. DBAccess.open() <----------+\n   ...                        |             ...                        |\n   ...                  Principal(ADMIN)    ...                  Principal(GUEST)\n2. Application.handle(..)     |          2. Application.handle(..)     |\n1. Server.serve(..) ----------+          1. Server.serve(..) ----------+\n```\n\nNormally, data is shared between caller and callee by passing it as method arguments, but this is not viable for a `Principal` shared between the server component and the data access component because the server component calls untrusted user code first. We need a better way to share data from the server component to the data access component than wiring it into a cascade of untrusted method invocations.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help components share data without resorting to method arguments. A thread-local variable is a variable of type `get()` or `set(...)` methods to read or write its value. Code in one thread automatically reads and writes its incarnation, while code in another thread automatically reads and writes its own distinct incarnation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from many components.\nHere is an example of how the server component and the data access component, both running in the same request-handling thread, can use a thread-local variable to share a `Principal`. The server component first declares a thread-local variable, `PRINCIPAL` (1). When `Server.serve(...)` is executed in a request-handling thread, it writes a suitable `Principal` to the thread-local variable (2), then calls user code. If and when user code calls `DBAccess.open()`, the data access component reads the thread-local variable (3) to obtain the `Principal` of the request-handling thread. Only if the `Principal` indicates suitable permissions is database access permitted (4).\n```\nclass Server {\n    final static ThreadLocal<Principal> PRINCIPAL = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAuthorized() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        PRINCIPAL.set(principal);                                         // (2)\n        Application.handle(request, response);\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                           // (3)\n        if (!principal.canOpen()) throw new InvalidPrincipalException();\n        return newConnection(...);                                        // (4)\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `Principal` as a method argument when the server component calls user code, and when user code calls the data access component. The thread-local variable serves as a kind of hidden method argument: A thread which calls `PRINCIPAL.set(...)` in `Server.serve(...)` and then `PRINCIPAL.get()` in `DBAccess.open()` will automatically see its own incarnation of the `PRINCIPAL` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `Principal` value for the current thread.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get()` method of a thread-local variable can call the `set(...)` method of that variable at any time. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between components. However, this can lead to spaghetti-like data flow, and to programs in which it is hard to discern which component updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one component to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's incarnation of a thread-local variable is written via the `set(...)` method, the incarnation is retained for the lifetime of the thread, or until code in the thread calls the `remove()` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because thread-local variables are mutable, and the `ThreadLocal` API requires that mutation in one thread is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set(...)` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads (`Server.serve(...)`, `Application.handle(...)`, and `DBAccess.open()` would all execute in a new virtual thread for each incoming request.\nIt would obviously be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has mutable thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain immutable and inheritable per-thread data for thousands or millions of virtual threads. Because these per-thread variables would be immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between components in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many components.\nLike a thread-local variable, a scoped value has multiple incarnations, one per thread. The particular incarnation that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once and is then immutable, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where(...)`, presenting a scoped value and the object to which it is to be bound. The call to `run(...)` _binds_ the scoped value, providing an incarnation that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run(...)` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run(...)` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe syntactic structure of the code delineates the period of time when a thread can read its incarnation of a scoped value. This bounded lifetime, combined with immutability, greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set(...)` method that lets faraway code change the scoped value at any time. Immutability also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. This is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run(...)` method produces an incarnation of V that is usable by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run(...)`. The unfolding execution of those methods defines a dynamic scope; the incarnation is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the server component declares a scoped value instead of a thread-local variable. At (2), the server component calls `ScopedValue.where(...)` and `run(...)` instead of a thread-local variable's `set(...)` method.\n```\nclass Server {\n    final static ScopedValue<Principal> PRINCIPAL =  ScopedValue.newInstance(); // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAdmin() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        ScopedValue.where(PRINCIPAL, principal)                            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (3)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\nTogether, `where(...)` and `run(...)` provide one-way sharing of data from the server component to the data access component. The scoped value passed to `where(...)` is bound to the corresponding object for the lifetime of the `run(...)` call, so `PRINCIPAL.get()` in any method called from `run(...)` will read that value. Accordingly, when `Server.serve(...)` calls user code, and user code calls `DBAccess.open()`, the value read from the scoped value (3) is the value written by `Server.serve(...)` earlier in the thread.\nThe binding established by `run(...)` is usable only in code called from `run(...)`. If `PRINCIPAL.get()` appeared in `Server.serve(...)` after the call to `run(...)`, an exception would be thrown because `PRINCIPAL` is no longer bound in the thread.\n### Rebinding scoped values\nThe immutability of scoped values means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees in the thread. The `ScopedValue` API allows a new binding to be established for nested calls.\nAs an example, consider a third component of the web framework: a logging component with a method `void log(Supplier<String> formatter)`. User code passes a lambda expression to the `log(...)` method; if logging is enabled, the method calls `formatter.get()` to evaluate the lambda expression and then prints the result. Although the user code may have permission to access the database, the lambda expression should not, since it only needs to format text. Accordingly, the scoped value that was initially bound in `Server.serve(...)` should be rebound to a guest `Principal` for the lifetime of `formatter.get()`:\n```\n8. InvalidPrincipalException()\n7. DBAccess.open() <--------------------------+  X---------+\n   ...                                        |            |\n   ...                                  Principal(GUEST)   |\n4. Supplier.get()                             |            |\n3. Logger.log(() -> { DBAccess.open(); }) ----+      Principal(ADMIN)\n2. Application.handle(..)                                  |\n1. Server.serve(..) ---------------------------------------+\n```\n\nHere is the code for `log(...)` with rebinding. It obtains a guest `Principal` (1) and passes it as the new binding for the scoped value `PRINCIPAL` (2). For the lifetime of the invocation of `call` (3), `PRINCIPAL.get()` will read this new value. Thus, if the user code passes a malicious lambda expression to `log(...)` that performs `DBAccess.open()`, the check in `DBAccess.open()` will read the guest `Principal` from `PRINCIPAL` and throw an `InvalidPrincipalException`.\n```\nclass Logger {\n    void log(Supplier<String> formatter) {\n        if (loggingEnabled) {\n            var guest = Principal.createGuest();                      // (1)\n            var message = ScopedValue.where(Server.PRINCIPAL, guest)  // (2)\n                                     .call(() -> formatter.get());    // (3)\n            write(logFile, \"%s %s\".format(timeStamp(), message));\n        }\n    }\n}\n```\n\n(We here use `call(...)` instead of `run(...)` to invoke the formatter because the result of the lambda expression is needed.) The syntactic structure of `where(...)` and `call(...)` means that the rebinding is only visible in the nested dynamic scope introduced by `call(...)`. The body of `log(...)` cannot change the binding seen by that method itself but can change the binding seen by its callees, such as the `formatter.get(...)` method. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread can execute framework code from the server component, then user code from the application developer, then more framework code from the data access component. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nData shared by a component running in the request-handling thread needs to be available to components running in child threads. Otherwise, when user code running in a child thread calls the data access component, that component \u2014 now also running in the child thread \u2014 will be unable to check the `Principal` shared by the server component running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API (`StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code, in a variant of the `Application.handle(...)` method called from `Server.serve(...)`. The user code calls `StructuredTaskScope.fork(...)` (1, 2) to run the `findUser()` and `fetchOrder()` methods concurrently, in their own virtual threads. Each method calls the data access component (3), which as before consults the scoped value `PRINCIPAL` (4). Further details of the user code are not discussed here; see \n```\nclass Application {\n    Response handle() throws ExecutionException, InterruptedException {\n        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n            Future<String>  user  = scope.fork(() -> findUser());          // (1)\n            Future<Integer> order = scope.fork(() -> fetchOrder());        // (2)\n            scope.join().throwIfFailed();  // Wait for both forks\n            return new Response(user.resultNow(), order.resultNow());\n        }\n    }\n\n    String findUser() {\n        ... DBAccess.open() ...                                            // (3)\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (4)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\n`StructuredTaskScope.fork(...)` ensures that the binding of the scoped value `PRINCIPAL` made in the request-handling thread \u2014 [when Server.serve(...) called ScopedValue.where(...)](https://openjdk.org/jeps/429#Web-framework-example-ScopedValue-code) \u2014 is automatically visible to `PRINCIPAL.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                           Thread 2\n--------                           --------\n                                   8. DBAccess.newConnection()\n                                   7. DBAccess.open() <----------+\n                                   ...                           |\n                                   ...                     Principal(ADMIN)\n                                   4. Application.findUser()     |\n3. StructuredTaskScope.fork(..)                                  |\n2. Application.handle(..)                                        |\n1. Server.serve(..) ---------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run(...)` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where(...)` and `run(...)`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set(...)` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 7
      },
      "classification": "-",
      "action": " ",
      "index": 7,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Avoid rebinding scoped values unnecessarily",
      "rule_idea": "Scoped values should not be rebound with the same value within nested scopes as this creates unnecessary overhead. Only rebind when a different value is needed for callees.",
      "code_examples": [
        {
          "non_compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void outer() {\n    ScopedValue.where(VALUE, \"test\").run(() -> {\n        ScopedValue.where(VALUE, \"test\").run(() -> inner()); // Unnecessary rebinding\n    });\n}",
          "compliant": "private static final ScopedValue<String> VALUE = ScopedValue.newInstance();\n\npublic void outer() {\n    ScopedValue.where(VALUE, \"test\").run(() -> {\n        inner(); // Use existing binding\n    });\n}"
        }
      ],
      "sources": [
        {
          "url": "https://openjdk.org/jeps/464",
          "source_text": "# JEP 464: Scoped Values (Second Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 22  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 446: Scoped Values (Preview)](https://openjdk.org/jeps/446)  \n| [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2023/10/26 12:05  \nUpdated | 2025/02/25 16:32  \nIssue | [8318898](https://bugs.openjdk.org/browse/JDK-8318898)  \n## Summary\nIntroduce _scoped values_ , which enable managed sharing of immutable data both with child frames in the same thread, and with child threads. Scoped values are easier to reason about than thread-local variables and have lower space and time costs, especially when used in combination with [Virtual Threads](https://openjdk.org/jeps/444) and [Structured Concurrency](https://openjdk.org/jeps/462). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nScoped values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429) and became a preview API in JDK 21 via [JEP 446](https://openjdk.org/jeps/446). We here propose to re-preview the API in JDK 22, without change, in order to gain additional experience and feedback.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data is visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller can only be retrieved by legitimate callees.\n  * _Performance_ \u2014 Data can be efficiently shared across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a final static field and its accessibility is set to private, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. Although a thread-local variable solves the problem of sharing data private between a caller and an indirect callee this solution suffers from some drawbacks, which are described in more detail in the discussion that follows the example. In summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided.\nThe framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set()` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set()` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `final` `static` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(NAME, <value>)\n           .run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Framework {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 453](https://openjdk.org/jeps/453)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 453](https://openjdk.org/jeps/453#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/464#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, an instance of `java.text.SimpleDateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. Today, though, any code caching a `SimpleDateFormat` could move to using `DateTimeFormatter` because it can be stored in a `static final` field and shared between threads.\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the small subset described above. While this JEP only presents examples that use `ScopedValue<V>.where(V, <value>).run(aRunnable)`, there are more ways to bind a scoped value. For example, the API also provides a `Callable` version which returns a value and may also throw an `Exception`:\n```\ntry {\n        var result = ScopedValue.where(X, \"hello\").call(() -> bar());\n        catch (Exception e) {\n            handleFailure(e);\n        }\n        ...\n```\n\nAdditionally, there are abbreviated versions of the binding methods. For example, `ScopedValue<V>.runWhere(V, <value>, aRunnable)` is a short form of `ScopedValue<V>.where(V, <value>).run(aRunnable)`. While this short form is sometimes convenient, it only allows a single scoped value to be bound at a time.\nThe full scoped value API is to be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. Scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 8
      },
      "classification": "-",
      "action": " ",
      "index": 8,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Use callWhere instead of runWhere when operation returns value",
      "rule_idea": "When the operation passed to a scoped value binding method needs to return a value, use ScopedValue.callWhere instead of ScopedValue.runWhere to properly handle the return type.",
      "code_examples": [
        {
          "non_compliant": "String result = ScopedValue.runWhere(CONTEXT, value, () -> computeResult());",
          "compliant": "String result = ScopedValue.callWhere(CONTEXT, value, () -> computeResult());"
        }
      ],
      "sources": [
        {
          "url": "https://openjdk.org/jeps/481",
          "source_text": "# JEP 481: Scoped Values (Third Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 23  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \n| [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2024/04/24 14:31  \nUpdated | 2025/02/25 16:32  \nIssue | [8331056](https://bugs.openjdk.org/browse/JDK-8331056)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429), became a preview API in JDK 21 via [JEP 446](https://openjdk.org/jeps/446), and was re-previewed in JDK 22 via [JEP 464](https://openjdk.org/jeps/464).\nWe here propose to re-preview the API in JDK 23 in order to gain additional experience and feedback, with one change:\n  * The type of the operation parameter of the [`ScopedValue.callWhere`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html#callWhere\\(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp\\)) method is now a new functional interface which allows the Java compiler to infer whether a checked exception might be thrown. With this change, the \n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `final` `static` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type [`ScopedValue`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html). It is typically declared as a `final` `static` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.runWhere`, presenting a scoped value and the object to which it is to be bound. The call to `runWhere` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as an argument. During the lifetime of the `runWhere` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `runWhere` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method\nScopedValue.runWhere(NAME, <value>,\n    () -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `runWhere` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `runWhere`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.runWhere` instead of a thread-local variable's `set` method.\n```\nclass Framework {\n\n    private final static ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.runWhere(CONTEXT, context,          // (2)\n                   () -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nThe `runWhere` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `runWhere` is bound to the corresponding object for the lifetime of the `runWhere` call, so `CONTEXT.get()` in any method called from `runWhere` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `runWhere` is usable only in code called from `runWhere`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `runWhere`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.runWhere(X, \"hello\", () -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.runWhere(X, \"goodbye\", () -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/481#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.runWhere`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `runWhere` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.runWhere`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the small subset described above. While here we only present examples that use `ScopedValue<V>.runWhere(V, <value>, aRunnable)`, there are more ways to bind a scoped value. For example, the API also provides a version which returns a value and may also throw an `Exception`:\n```\ntry {\n        var result = ScopedValue.callWhere(X, \"hello\", () -> bar());\n        catch (Exception e) {\n            handleFailure(e);\n        }\n        ...\n```\n\nAdditionally, there are versions of the binding methods that can bind multiple scoped values at a call site.\nThe following example runs an operation with k1 bound (or rebound) to v1, and k2 bound (or rebound) to v2:\n```\nScopedValue.where(k1, v1).where(k2, v2).run(\n        () -> ... );\n```\n\nThis is both more efficient and much easier to read than nested invocations of `ScopedValue.runWhere`.\nThe full scoped value API can be found [here](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html).\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 9
      },
      "classification": "-",
      "action": " ",
      "index": 9,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Avoid using deprecated ScopedValue preview patterns",
      "rule_idea": "Since ScopedValue APIs are no longer preview in Java 25, developers should migrate away from any preview-specific usage patterns or workarounds that may have been necessary in earlier versions. This rule detects usage of preview-related patterns that are no longer needed.",
      "code_examples": [
        {
          "non_compliant": "// Using preview-specific workarounds\n@SuppressWarnings(\"preview\")\npublic class MyClass {\n    private static final ScopedValue<String> SCOPED_VAL = ScopedValue.newInstance();\n}",
          "compliant": "// Using stable API without preview suppressions\npublic class MyClass {\n    private static final ScopedValue<String> SCOPED_VAL = ScopedValue.newInstance();\n}"
        }
      ],
      "sources": [
        {
          "url": "https://data.javaalmanac.io/v1/jdk/versions/25/apidiffs/24",
          "source_text": "```\n{\"base\":{\"feature\":\"24\",\"vendor\":\"open\",\"version\":\"24.0.2+12-54\"},\"target\":{\"feature\":\"25\",\"vendor\":\"open\",\"version\":\"25+36-3489\"},\"deltas\":[{\"type\":\"module\",\"name\":\"java.base\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.io\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Console\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Console.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"print(Object)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"println()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"println(Object)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"readln()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"readln(String)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"}]},{\"type\":\"class\",\"name\":\"FilePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/FilePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"IO\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"class\",\"name\":\"OptionalDataException\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/OptionalDataException.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Reader\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"readAllAsString()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html#readAllAsString()\",\"csr\":\"JDK-8356909\"},{\"type\":\"method\",\"name\":\"readAllLines()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html#readAllLines()\",\"csr\":\"JDK-8356909\"}]},{\"type\":\"class\",\"name\":\"SerializablePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/SerializablePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile.attribute\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/attribute/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"UnknownAttribute\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/attribute/UnknownAttribute.html\",\"addedTags\":[\"implements CodeElement\"]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile.constantpool\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"ClassEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ClassEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(ClassDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ClassEntry.html#matches(java.lang.constant.ClassDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"MethodTypeEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/MethodTypeEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(MethodTypeDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/MethodTypeEntry.html#matches(java.lang.constant.MethodTypeDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"ModuleEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ModuleEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(ModuleDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ModuleEntry.html#matches(java.lang.constant.ModuleDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"PackageEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/PackageEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(PackageDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/PackageEntry.html#matches(java.lang.constant.PackageDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"StringEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/StringEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"equalsString(String)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/StringEntry.html#equalsString(java.lang.String)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"Utf8Entry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"isFieldType(ClassDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html#isFieldType(java.lang.constant.ClassDesc)\",\"csr\":\"JDK-8342210\"},{\"type\":\"method\",\"name\":\"isMethodType(MethodTypeDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html#isMethodType(java.lang.constant.MethodTypeDesc)\",\"csr\":\"JDK-8342210\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"ClassFile\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/ClassFile.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"JAVA_25_VERSION\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/ClassFile.html#JAVA_25_VERSION\",\"csr\":\"JDK-8343029\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.constant\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/constant/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DynamicCallSiteDesc\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/constant/DynamicCallSiteDesc.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.invoke\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"MethodHandleProxies\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandleProxies.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"MethodHandles\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandles.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.module\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/module/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ModuleDescriptor\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/module/ModuleDescriptor.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.reflect\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Modifier\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Modifier.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ReflectPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ReflectPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"enum\",\"name\":\"AccessFlag.Location\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"flags()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flags()\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flags(ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flags(java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flagsMask()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flagsMask()\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flagsMask(ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flagsMask(java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8347626\"}]},{\"type\":\"enum\",\"name\":\"AccessFlag\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"maskToAccessFlags(int, AccessFlag.Location, ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.html#maskToAccessFlags(int,java.lang.reflect.AccessFlag.Location,java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8297741\"}]},{\"type\":\"enum\",\"name\":\"ClassFileFormatVersion\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ClassFileFormatVersion.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"RELEASE_25\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ClassFileFormatVersion.html#RELEASE_25\",\"csr\":\"JDK-8343029\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.runtime\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ObjectMethods\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/ObjectMethods.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"SwitchBootstraps\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/SwitchBootstraps.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Boolean\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Boolean(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Boolean(boolean)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html#%3Cinit%3E(boolean)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Byte\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Byte(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Byte(byte)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html#%3Cinit%3E(byte)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Character\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Character.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Character(char)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Character.html#%3Cinit%3E(char)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Double\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Double(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Double(double)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html#%3Cinit%3E(double)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Float\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Float(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Float(double)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(double)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Float(float)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(float)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"IO\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/IO.html\",\"csr\":\"JDK-8353437\"},{\"type\":\"class\",\"name\":\"Integer\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Integer(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Integer(int)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html#%3Cinit%3E(int)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Long\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Long(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Long(long)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html#%3Cinit%3E(long)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Math\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"powExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#powExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"powExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#powExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(long,long)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedPowExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedPowExact(long,int)\",\"csr\":\"JDK-8356077\"}]},{\"type\":\"class\",\"name\":\"Package\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Package.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"RuntimePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/RuntimePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"Runtime\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Runtime.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ScopedValue.Carrier\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.Carrier.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"ScopedValue\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"Short\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Short(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Short(short)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html#%3Cinit%3E(short)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"StrictMath\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"powExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#powExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"powExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#powExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(long,long)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedPowExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedPowExact(long,int)\",\"csr\":\"JDK-8356077\"}]},{\"type\":\"interface\",\"name\":\"CharSequence\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/CharSequence.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getChars(int, int, char[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/CharSequence.html#getChars(int,int,char%5B%5D,int)\",\"csr\":\"JDK-8343111\"}]},{\"type\":\"interface\",\"name\":\"ScopedValue.CallableOp\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.CallableOp.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"StableValue\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html\",\"csr\":\"JDK-8342068\"}]},{\"type\":\"package\",\"name\":\"java.net\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HttpURLConnection\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/HttpURLConnection.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getPermission()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/HttpURLConnection.html#getPermission()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"InterfaceAddress\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/InterfaceAddress.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"NetPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/NetPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"URLConnection\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLConnection.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getPermission()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLConnection.html#getPermission()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"URLDecoder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLDecoder.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"URLEncoder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLEncoder.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"URLPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.nio.charset\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"CoderResult\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/CoderResult.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"CodingErrorAction\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/CodingErrorAction.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.nio.file\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LinkPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/LinkPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.nio\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"CharBuffer\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/CharBuffer.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getChars(int, int, char[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/CharBuffer.html#getChars(int,int,char%5B%5D,int)\",\"csr\":\"JDK-8343111\"}]}]},{\"type\":\"package\",\"name\":\"java.security.cert\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"X509CRL\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/X509CRL.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"X509Certificate\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/X509Certificate.html\",\"addedTags\":[\"implements DEREncodable\"]}]},{\"type\":\"package\",\"name\":\"java.security.spec\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"PKCS8EncodedKeySpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/PKCS8EncodedKeySpec.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"X509EncodedKeySpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html\",\"addedTags\":[\"implements DEREncodable\"]}]},{\"type\":\"package\",\"name\":\"java.security\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DrbgParameters\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DrbgParameters.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"KeyPair\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/KeyPair.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"PEMDecoder\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMDecoder.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"PEMEncoder\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMEncoder.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"PEMRecord\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMRecord.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"SecurityPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/SecurityPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"UnresolvedPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/UnresolvedPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"interface\",\"name\":\"AsymmetricKey\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/AsymmetricKey.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"interface\",\"name\":\"DEREncodable\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DEREncodable.html\",\"csr\":\"JDK-8329419\"}]},{\"type\":\"package\",\"name\":\"java.util.concurrent.locks\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LockSupport\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/LockSupport.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.util.concurrent\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Executors\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/Executors.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ForkJoinPool\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html\",\"addedTags\":[\"implements ScheduledExecutorService\"],\"deltas\":[{\"type\":\"method\",\"name\":\"cancelDelayedTasksOnShutdown()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#cancelDelayedTasksOnShutdown()\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"getDelayedTaskCount()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#getDelayedTaskCount()\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"schedule(Callable, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"schedule(Runnable, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"scheduleAtFixedRate(Runnable, long, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"scheduleWithFixedDelay(Runnable, long, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"submitWithTimeout(Callable, long, TimeUnit, Consumer)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#submitWithTimeout(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit,java.util.function.Consumer)\",\"csr\":\"JDK-8350493\"}]},{\"type\":\"class\",\"name\":\"StructuredTaskScope.FailedException\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.FailedException.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.ShutdownOnFailure\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.ShutdownOnSuccess\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.TimeoutException\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.TimeoutException.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Configuration\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Configuration.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Joiner\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Subtask\",\"status\":\"notmodified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"task()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"}]},{\"type\":\"interface\",\"name\":\"StructuredTaskScope\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html\",\"addedTags\":[\"abstract\",\"sealed\"],\"deltas\":[{\"type\":\"method\",\"name\":\"StructuredTaskScope()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"StructuredTaskScope(String, ThreadFactory)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"close()\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()\",\"addedTags\":[\"abstract\"]},{\"type\":\"method\",\"name\":\"ensureOwnerAndJoined()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"fork(Callable)\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)\",\"addedTags\":[\"abstract\"]},{\"type\":\"method\",\"name\":\"fork(Runnable)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.lang.Runnable)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"handleComplete(StructuredTaskScope.Subtask)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"isCancelled()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#isCancelled()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"isShutdown()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"join()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"join()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"joinUntil(Instant)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open(StructuredTaskScope.Joiner)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open(StructuredTaskScope.Joiner, Function)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner,java.util.function.Function)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"shutdown()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"toString()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"}]}]},{\"type\":\"package\",\"name\":\"java.util.zip\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Deflater\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Deflater.html\",\"addedTags\":[\"implements AutoCloseable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"close()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Deflater.html#close()\",\"csr\":\"JDK-8343768\"}]},{\"type\":\"class\",\"name\":\"Inflater\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Inflater.html\",\"addedTags\":[\"implements AutoCloseable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"close()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Inflater.html#close()\",\"csr\":\"JDK-8343768\"}]}]},{\"type\":\"package\",\"name\":\"java.util\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Base64\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Base64.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Collections\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Collections.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Currency\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Currency.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"availableCurrencies()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Currency.html#availableCurrencies()\",\"csr\":\"JDK-8347950\"}]},{\"type\":\"class\",\"name\":\"FormattableFlags\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/FormattableFlags.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"PropertyPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/PropertyPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"TimeZone\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"availableIDs()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html#availableIDs()\",\"csr\":\"JDK-8348325\"},{\"type\":\"method\",\"name\":\"availableIDs(int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html#availableIDs(int)\",\"csr\":\"JDK-8348325\"}]}]},{\"type\":\"package\",\"name\":\"javax.crypto.spec\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Builder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Builder.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Expand\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Expand.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.ExtractThenExpand\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.ExtractThenExpand.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Extract\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Extract.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"HKDFParameterSpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.html\",\"removedTags\":[\"preview\"]}]},{\"type\":\"package\",\"name\":\"javax.crypto\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"EncryptedPrivateKeyInfo\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html\",\"addedTags\":[\"implements DEREncodable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, Key, String, AlgorithmParameterSpec, Provider, SecureRandom)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,java.security.Key,java.lang.String,java.security.spec.AlgorithmParameterSpec,java.security.Provider,java.security.SecureRandom)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, char[])\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,char%5B%5D)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, char[], String, AlgorithmParameterSpec, Provider)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,char%5B%5D,java.lang.String,java.security.spec.AlgorithmParameterSpec,java.security.Provider)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"getKey(Key, Provider)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#getKey(java.security.Key,java.security.Provider)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"getKey(char[])\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#getKey(char%5B%5D)\",\"csr\":\"JDK-8329419\"}]},{\"type\":\"class\",\"name\":\"KDFSpi\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDFSpi.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"KDF\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDF.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"KDFParameters\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDFParameters.html\",\"removedTags\":[\"preview\"]}]},{\"type\":\"package\",\"name\":\"javax.net.ssl\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ExtendedSSLSession\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"exportKeyingMaterialData(String, byte[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html#exportKeyingMaterialData(java.lang.String,byte%5B%5D,int)\",\"csr\":\"JDK-8348370\"},{\"type\":\"method\",\"name\":\"exportKeyingMaterialKey(String, String, byte[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html#exportKeyingMaterialKey(java.lang.String,java.lang.String,byte%5B%5D,int)\",\"csr\":\"JDK-8348370\"}]},{\"type\":\"class\",\"name\":\"SSLPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/SSLPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.security.auth\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"AuthPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/AuthPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"PrivateCredentialPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/PrivateCredentialPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.compiler\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.lang.model\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/package-summary.html\",\"deltas\":[{\"type\":\"enum\",\"name\":\"SourceVersion\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/SourceVersion.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"RELEASE_25\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/SourceVersion.html#RELEASE_25\",\"csr\":\"JDK-8343000\"}]}]}]},{\"type\":\"module\",\"name\":\"java.desktop\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.sound\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/sound/package-summary.html\",\"csr\":\"JDK-8356200\"},{\"type\":\"package\",\"name\":\"javax.swing.plaf.basic\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/basic/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"BasicSliderUI\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/basic/BasicSliderUI.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"BasicSliderUI()\",\"status\":\"removed\",\"csr\":\"JDK-8345648\"}]}]},{\"type\":\"package\",\"name\":\"javax.swing.plaf.synth\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/synth/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"SynthLookAndFeel\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/synth/SynthLookAndFeel.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"load(URL)\",\"status\":\"removed\",\"csr\":\"JDK-8351238\"}]}]}]},{\"type\":\"module\",\"name\":\"java.logging\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.util.logging\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/java/util/logging/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LoggingPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/java/util/logging/LoggingPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.lang.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/java/lang/management/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ManagementPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/java/lang/management/ManagementPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management.modelmbean\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DescriptorSupport\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"DescriptorSupport(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html#%3Cinit%3E(java.lang.String)\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"method\",\"name\":\"toXMLString()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html#toXMLString()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"XMLParseException\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/XMLParseException.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management.remote\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/remote/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"SubjectDelegationPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/remote/SubjectDelegationPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"MBeanPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"MBeanServerPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanServerPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"MBeanTrustPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanTrustPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.net.http\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.net.http\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HttpResponse.BodyHandlers\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"limiting(HttpResponse.BodyHandler, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html#limiting(java.net.http.HttpResponse.BodyHandler,long)\",\"csr\":\"JDK-8347904\"}]},{\"type\":\"class\",\"name\":\"HttpResponse.BodySubscribers\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodySubscribers.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"limiting(HttpResponse.BodySubscriber, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodySubscribers.html#limiting(java.net.http.HttpResponse.BodySubscriber,long)\",\"csr\":\"JDK-8347904\"}]},{\"type\":\"interface\",\"name\":\"HttpResponse\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"connectionLabel()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.html#connectionLabel()\",\"csr\":\"JDK-8352751\"}]}]}]},{\"type\":\"module\",\"name\":\"java.security.jgss\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.security.auth.kerberos\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DelegationPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/DelegationPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"ServicePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/ServicePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.xml.crypto\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.xml.crypto.dsig\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"SignatureMethod\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"ECDSA_SHA3_224\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_224\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_256\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_256\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_384\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_384\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_512\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_512\",\"csr\":\"JDK-8345411\"}]}]}]}]}\n```\n\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 10
      },
      "classification": "-",
      "action": " ",
      "index": 10,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Use ScopedValue.Carrier for multiple scoped values",
      "rule_idea": "When working with multiple ScopedValue instances, use ScopedValue.Carrier to bind multiple values efficiently in a single operation rather than nesting multiple where() calls. This improves readability and performance.",
      "code_examples": [
        {
          "non_compliant": "private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();\nprivate static final ScopedValue<String> SESSION_ID = ScopedValue.newInstance();\n\npublic void handleRequest(String userId, String sessionId) {\n    // Nested binding - less efficient\n    ScopedValue.where(USER_ID, userId).run(() -> {\n        ScopedValue.where(SESSION_ID, sessionId).run(() -> {\n            processRequest();\n        });\n    });\n}",
          "compliant": "private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();\nprivate static final ScopedValue<String> SESSION_ID = ScopedValue.newInstance();\n\npublic void handleRequest(String userId, String sessionId) {\n    // Using Carrier for multiple bindings\n    ScopedValue.where(USER_ID, userId)\n              .where(SESSION_ID, sessionId)\n              .run(() -> processRequest());\n}"
        }
      ],
      "sources": [
        {
          "url": "https://data.javaalmanac.io/v1/jdk/versions/25/apidiffs/24",
          "source_text": "```\n{\"base\":{\"feature\":\"24\",\"vendor\":\"open\",\"version\":\"24.0.2+12-54\"},\"target\":{\"feature\":\"25\",\"vendor\":\"open\",\"version\":\"25+36-3489\"},\"deltas\":[{\"type\":\"module\",\"name\":\"java.base\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.io\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Console\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Console.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"print(Object)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"println()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"println(Object)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"readln()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"readln(String)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"}]},{\"type\":\"class\",\"name\":\"FilePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/FilePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"IO\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"class\",\"name\":\"OptionalDataException\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/OptionalDataException.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Reader\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"readAllAsString()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html#readAllAsString()\",\"csr\":\"JDK-8356909\"},{\"type\":\"method\",\"name\":\"readAllLines()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html#readAllLines()\",\"csr\":\"JDK-8356909\"}]},{\"type\":\"class\",\"name\":\"SerializablePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/SerializablePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile.attribute\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/attribute/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"UnknownAttribute\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/attribute/UnknownAttribute.html\",\"addedTags\":[\"implements CodeElement\"]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile.constantpool\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"ClassEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ClassEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(ClassDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ClassEntry.html#matches(java.lang.constant.ClassDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"MethodTypeEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/MethodTypeEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(MethodTypeDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/MethodTypeEntry.html#matches(java.lang.constant.MethodTypeDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"ModuleEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ModuleEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(ModuleDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/ModuleEntry.html#matches(java.lang.constant.ModuleDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"PackageEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/PackageEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"matches(PackageDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/PackageEntry.html#matches(java.lang.constant.PackageDesc)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"StringEntry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/StringEntry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"equalsString(String)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/StringEntry.html#equalsString(java.lang.String)\",\"csr\":\"JDK-8342210\"}]},{\"type\":\"interface\",\"name\":\"Utf8Entry\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"isFieldType(ClassDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html#isFieldType(java.lang.constant.ClassDesc)\",\"csr\":\"JDK-8342210\"},{\"type\":\"method\",\"name\":\"isMethodType(MethodTypeDesc)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/constantpool/Utf8Entry.html#isMethodType(java.lang.constant.MethodTypeDesc)\",\"csr\":\"JDK-8342210\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.classfile\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"ClassFile\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/ClassFile.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"JAVA_25_VERSION\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/classfile/ClassFile.html#JAVA_25_VERSION\",\"csr\":\"JDK-8343029\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.constant\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/constant/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DynamicCallSiteDesc\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/constant/DynamicCallSiteDesc.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.invoke\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"MethodHandleProxies\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandleProxies.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"MethodHandles\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandles.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.module\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/module/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ModuleDescriptor\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/module/ModuleDescriptor.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang.reflect\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Modifier\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Modifier.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ReflectPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ReflectPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"enum\",\"name\":\"AccessFlag.Location\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"flags()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flags()\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flags(ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flags(java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flagsMask()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flagsMask()\",\"csr\":\"JDK-8347626\"},{\"type\":\"method\",\"name\":\"flagsMask(ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.Location.html#flagsMask(java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8347626\"}]},{\"type\":\"enum\",\"name\":\"AccessFlag\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"maskToAccessFlags(int, AccessFlag.Location, ClassFileFormatVersion)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/AccessFlag.html#maskToAccessFlags(int,java.lang.reflect.AccessFlag.Location,java.lang.reflect.ClassFileFormatVersion)\",\"csr\":\"JDK-8297741\"}]},{\"type\":\"enum\",\"name\":\"ClassFileFormatVersion\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ClassFileFormatVersion.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"RELEASE_25\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/ClassFileFormatVersion.html#RELEASE_25\",\"csr\":\"JDK-8343029\"}]}]},{\"type\":\"package\",\"name\":\"java.lang.runtime\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ObjectMethods\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/ObjectMethods.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"SwitchBootstraps\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/runtime/SwitchBootstraps.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.lang\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Boolean\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Boolean(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Boolean(boolean)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Boolean.html#%3Cinit%3E(boolean)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Byte\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Byte(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Byte(byte)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Byte.html#%3Cinit%3E(byte)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Character\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Character.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Character(char)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Character.html#%3Cinit%3E(char)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Double\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Double(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Double(double)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Double.html#%3Cinit%3E(double)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Float\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Float(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Float(double)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(double)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Float(float)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Float.html#%3Cinit%3E(float)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"IO\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/IO.html\",\"csr\":\"JDK-8353437\"},{\"type\":\"class\",\"name\":\"Integer\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Integer(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Integer(int)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Integer.html#%3Cinit%3E(int)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Long\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Long(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Long(long)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Long.html#%3Cinit%3E(long)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"Math\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"powExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#powExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"powExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#powExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedMultiplyExact(long,long)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedPowExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#unsignedPowExact(long,int)\",\"csr\":\"JDK-8356077\"}]},{\"type\":\"class\",\"name\":\"Package\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Package.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"RuntimePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/RuntimePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"Runtime\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Runtime.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ScopedValue.Carrier\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.Carrier.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"ScopedValue\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"Short\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"Short(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html#%3Cinit%3E(java.lang.String)\",\"removedTags\":[\"forRemoval\"]},{\"type\":\"method\",\"name\":\"Short(short)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Short.html#%3Cinit%3E(short)\",\"removedTags\":[\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"StrictMath\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"powExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#powExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"powExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#powExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(long,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedMultiplyExact(long, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedMultiplyExact(long,long)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(int, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedPowExact(int,int)\",\"csr\":\"JDK-8356077\"},{\"type\":\"method\",\"name\":\"unsignedPowExact(long, int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StrictMath.html#unsignedPowExact(long,int)\",\"csr\":\"JDK-8356077\"}]},{\"type\":\"interface\",\"name\":\"CharSequence\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/CharSequence.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getChars(int, int, char[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/CharSequence.html#getChars(int,int,char%5B%5D,int)\",\"csr\":\"JDK-8343111\"}]},{\"type\":\"interface\",\"name\":\"ScopedValue.CallableOp\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.CallableOp.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"StableValue\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html\",\"csr\":\"JDK-8342068\"}]},{\"type\":\"package\",\"name\":\"java.net\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HttpURLConnection\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/HttpURLConnection.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getPermission()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/HttpURLConnection.html#getPermission()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"InterfaceAddress\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/InterfaceAddress.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"NetPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/NetPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"URLConnection\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLConnection.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getPermission()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLConnection.html#getPermission()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"URLDecoder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLDecoder.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"URLEncoder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLEncoder.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"URLPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/net/URLPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.nio.charset\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"CoderResult\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/CoderResult.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"CodingErrorAction\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/charset/CodingErrorAction.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.nio.file\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LinkPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/LinkPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"java.nio\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"CharBuffer\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/CharBuffer.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"getChars(int, int, char[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/CharBuffer.html#getChars(int,int,char%5B%5D,int)\",\"csr\":\"JDK-8343111\"}]}]},{\"type\":\"package\",\"name\":\"java.security.cert\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"X509CRL\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/X509CRL.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"X509Certificate\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/cert/X509Certificate.html\",\"addedTags\":[\"implements DEREncodable\"]}]},{\"type\":\"package\",\"name\":\"java.security.spec\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"PKCS8EncodedKeySpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/PKCS8EncodedKeySpec.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"X509EncodedKeySpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html\",\"addedTags\":[\"implements DEREncodable\"]}]},{\"type\":\"package\",\"name\":\"java.security\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DrbgParameters\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DrbgParameters.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"KeyPair\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/KeyPair.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"class\",\"name\":\"PEMDecoder\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMDecoder.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"PEMEncoder\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMEncoder.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"PEMRecord\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMRecord.html\",\"csr\":\"JDK-8329419\"},{\"type\":\"class\",\"name\":\"SecurityPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/SecurityPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"UnresolvedPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/UnresolvedPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"interface\",\"name\":\"AsymmetricKey\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/AsymmetricKey.html\",\"addedTags\":[\"implements DEREncodable\"]},{\"type\":\"interface\",\"name\":\"DEREncodable\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DEREncodable.html\",\"csr\":\"JDK-8329419\"}]},{\"type\":\"package\",\"name\":\"java.util.concurrent.locks\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LockSupport\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/LockSupport.html\",\"addedTags\":[\"final\"]}]},{\"type\":\"package\",\"name\":\"java.util.concurrent\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Executors\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/Executors.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"ForkJoinPool\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html\",\"addedTags\":[\"implements ScheduledExecutorService\"],\"deltas\":[{\"type\":\"method\",\"name\":\"cancelDelayedTasksOnShutdown()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#cancelDelayedTasksOnShutdown()\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"getDelayedTaskCount()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#getDelayedTaskCount()\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"schedule(Callable, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"schedule(Runnable, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"scheduleAtFixedRate(Runnable, long, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"scheduleWithFixedDelay(Runnable, long, long, TimeUnit)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)\",\"csr\":\"JDK-8350493\"},{\"type\":\"method\",\"name\":\"submitWithTimeout(Callable, long, TimeUnit, Consumer)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#submitWithTimeout(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit,java.util.function.Consumer)\",\"csr\":\"JDK-8350493\"}]},{\"type\":\"class\",\"name\":\"StructuredTaskScope.FailedException\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.FailedException.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.ShutdownOnFailure\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.ShutdownOnSuccess\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"class\",\"name\":\"StructuredTaskScope.TimeoutException\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.TimeoutException.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Configuration\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Configuration.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Joiner\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html\",\"csr\":\"JDK-8342487\"},{\"type\":\"interface\",\"name\":\"StructuredTaskScope.Subtask\",\"status\":\"notmodified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"task()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"}]},{\"type\":\"interface\",\"name\":\"StructuredTaskScope\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html\",\"addedTags\":[\"abstract\",\"sealed\"],\"deltas\":[{\"type\":\"method\",\"name\":\"StructuredTaskScope()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"StructuredTaskScope(String, ThreadFactory)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8353437\"},{\"type\":\"method\",\"name\":\"close()\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()\",\"addedTags\":[\"abstract\"]},{\"type\":\"method\",\"name\":\"ensureOwnerAndJoined()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"fork(Callable)\",\"status\":\"modified\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)\",\"addedTags\":[\"abstract\"]},{\"type\":\"method\",\"name\":\"fork(Runnable)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.lang.Runnable)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"handleComplete(StructuredTaskScope.Subtask)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"isCancelled()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#isCancelled()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"isShutdown()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"join()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"join()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"joinUntil(Instant)\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open()\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open()\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open(StructuredTaskScope.Joiner)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"open(StructuredTaskScope.Joiner, Function)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner,java.util.function.Function)\",\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"shutdown()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"},{\"type\":\"method\",\"name\":\"toString()\",\"status\":\"removed\",\"preview\":true,\"csr\":\"JDK-8342487\"}]}]},{\"type\":\"package\",\"name\":\"java.util.zip\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Deflater\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Deflater.html\",\"addedTags\":[\"implements AutoCloseable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"close()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Deflater.html#close()\",\"csr\":\"JDK-8343768\"}]},{\"type\":\"class\",\"name\":\"Inflater\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Inflater.html\",\"addedTags\":[\"implements AutoCloseable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"close()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/zip/Inflater.html#close()\",\"csr\":\"JDK-8343768\"}]}]},{\"type\":\"package\",\"name\":\"java.util\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"Base64\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Base64.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Collections\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Collections.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"Currency\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Currency.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"availableCurrencies()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Currency.html#availableCurrencies()\",\"csr\":\"JDK-8347950\"}]},{\"type\":\"class\",\"name\":\"FormattableFlags\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/FormattableFlags.html\",\"addedTags\":[\"final\"]},{\"type\":\"class\",\"name\":\"PropertyPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/PropertyPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"TimeZone\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"availableIDs()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html#availableIDs()\",\"csr\":\"JDK-8348325\"},{\"type\":\"method\",\"name\":\"availableIDs(int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/TimeZone.html#availableIDs(int)\",\"csr\":\"JDK-8348325\"}]}]},{\"type\":\"package\",\"name\":\"javax.crypto.spec\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Builder\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Builder.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Expand\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Expand.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.ExtractThenExpand\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.ExtractThenExpand.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"HKDFParameterSpec.Extract\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.Extract.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"HKDFParameterSpec\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/spec/HKDFParameterSpec.html\",\"removedTags\":[\"preview\"]}]},{\"type\":\"package\",\"name\":\"javax.crypto\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"EncryptedPrivateKeyInfo\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html\",\"addedTags\":[\"implements DEREncodable\"],\"deltas\":[{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, Key, String, AlgorithmParameterSpec, Provider, SecureRandom)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,java.security.Key,java.lang.String,java.security.spec.AlgorithmParameterSpec,java.security.Provider,java.security.SecureRandom)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, char[])\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,char%5B%5D)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"encryptKey(PrivateKey, char[], String, AlgorithmParameterSpec, Provider)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#encryptKey(java.security.PrivateKey,char%5B%5D,java.lang.String,java.security.spec.AlgorithmParameterSpec,java.security.Provider)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"getKey(Key, Provider)\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#getKey(java.security.Key,java.security.Provider)\",\"csr\":\"JDK-8329419\"},{\"type\":\"method\",\"name\":\"getKey(char[])\",\"status\":\"added\",\"preview\":true,\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/EncryptedPrivateKeyInfo.html#getKey(char%5B%5D)\",\"csr\":\"JDK-8329419\"}]},{\"type\":\"class\",\"name\":\"KDFSpi\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDFSpi.html\",\"removedTags\":[\"preview\"]},{\"type\":\"class\",\"name\":\"KDF\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDF.html\",\"removedTags\":[\"preview\"]},{\"type\":\"interface\",\"name\":\"KDFParameters\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KDFParameters.html\",\"removedTags\":[\"preview\"]}]},{\"type\":\"package\",\"name\":\"javax.net.ssl\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ExtendedSSLSession\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"exportKeyingMaterialData(String, byte[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html#exportKeyingMaterialData(java.lang.String,byte%5B%5D,int)\",\"csr\":\"JDK-8348370\"},{\"type\":\"method\",\"name\":\"exportKeyingMaterialKey(String, String, byte[], int)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/ExtendedSSLSession.html#exportKeyingMaterialKey(java.lang.String,java.lang.String,byte%5B%5D,int)\",\"csr\":\"JDK-8348370\"}]},{\"type\":\"class\",\"name\":\"SSLPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/SSLPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.security.auth\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"AuthPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/AuthPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"PrivateCredentialPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/security/auth/PrivateCredentialPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.compiler\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.lang.model\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/package-summary.html\",\"deltas\":[{\"type\":\"enum\",\"name\":\"SourceVersion\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/SourceVersion.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"RELEASE_25\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.compiler/javax/lang/model/SourceVersion.html#RELEASE_25\",\"csr\":\"JDK-8343000\"}]}]}]},{\"type\":\"module\",\"name\":\"java.desktop\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.sound\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/sound/package-summary.html\",\"csr\":\"JDK-8356200\"},{\"type\":\"package\",\"name\":\"javax.swing.plaf.basic\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/basic/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"BasicSliderUI\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/basic/BasicSliderUI.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"BasicSliderUI()\",\"status\":\"removed\",\"csr\":\"JDK-8345648\"}]}]},{\"type\":\"package\",\"name\":\"javax.swing.plaf.synth\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/synth/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"SynthLookAndFeel\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.desktop/javax/swing/plaf/synth/SynthLookAndFeel.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"load(URL)\",\"status\":\"removed\",\"csr\":\"JDK-8351238\"}]}]}]},{\"type\":\"module\",\"name\":\"java.logging\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.util.logging\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/java/util/logging/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"LoggingPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.logging/java/util/logging/LoggingPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.lang.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/java/lang/management/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"ManagementPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/java/lang/management/ManagementPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management.modelmbean\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DescriptorSupport\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"DescriptorSupport(String)\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html#%3Cinit%3E(java.lang.String)\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"method\",\"name\":\"toXMLString()\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/DescriptorSupport.html#toXMLString()\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"class\",\"name\":\"XMLParseException\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/modelmbean/XMLParseException.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management.remote\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/remote/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"SubjectDelegationPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/remote/SubjectDelegationPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]},{\"type\":\"package\",\"name\":\"javax.management\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"MBeanPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"MBeanServerPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanServerPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"MBeanTrustPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.management/javax/management/MBeanTrustPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.net.http\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"java.net.http\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"HttpResponse.BodyHandlers\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"limiting(HttpResponse.BodyHandler, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html#limiting(java.net.http.HttpResponse.BodyHandler,long)\",\"csr\":\"JDK-8347904\"}]},{\"type\":\"class\",\"name\":\"HttpResponse.BodySubscribers\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodySubscribers.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"limiting(HttpResponse.BodySubscriber, long)\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.BodySubscribers.html#limiting(java.net.http.HttpResponse.BodySubscriber,long)\",\"csr\":\"JDK-8347904\"}]},{\"type\":\"interface\",\"name\":\"HttpResponse\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.html\",\"deltas\":[{\"type\":\"method\",\"name\":\"connectionLabel()\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpResponse.html#connectionLabel()\",\"csr\":\"JDK-8352751\"}]}]}]},{\"type\":\"module\",\"name\":\"java.security.jgss\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.security.auth.kerberos\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/package-summary.html\",\"deltas\":[{\"type\":\"class\",\"name\":\"DelegationPermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/DelegationPermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]},{\"type\":\"class\",\"name\":\"ServicePermission\",\"status\":\"modified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.security.jgss/javax/security/auth/kerberos/ServicePermission.html\",\"addedTags\":[\"deprecated\",\"forRemoval\"]}]}]},{\"type\":\"module\",\"name\":\"java.xml.crypto\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/module-summary.html\",\"deltas\":[{\"type\":\"package\",\"name\":\"javax.xml.crypto.dsig\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/package-summary.html\",\"deltas\":[{\"type\":\"interface\",\"name\":\"SignatureMethod\",\"status\":\"notmodified\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html\",\"deltas\":[{\"type\":\"field\",\"name\":\"ECDSA_SHA3_224\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_224\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_256\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_256\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_384\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_384\",\"csr\":\"JDK-8345411\"},{\"type\":\"field\",\"name\":\"ECDSA_SHA3_512\",\"status\":\"added\",\"javadoc\":\"https://docs.oracle.com/en/java/javase/25/docs/api/java.xml.crypto/javax/xml/crypto/dsig/SignatureMethod.html#ECDSA_SHA3_512\",\"csr\":\"JDK-8345411\"}]}]}]}]}\n```\n\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 11
      },
      "classification": "-",
      "action": " ",
      "index": 11,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Use chained where() calls for multiple ScopedValue bindings",
      "rule_idea": "When binding multiple scoped values simultaneously, use the fluent API with chained where() calls instead of nested runWhere() or where().run() invocations. This approach improves both readability and performance by avoiding unnecessary nesting and creating a single binding context for all values.",
      "code_examples": [
        {
          "non_compliant": "ScopedValue.runWhere(k1, v1, () -> {\n    ScopedValue.runWhere(k2, v2, () -> {\n        operation();\n    });\n});",
          "compliant": "ScopedValue.where(k1, v1).where(k2, v2).run(() -> operation());"
        },
        {
          "non_compliant": "ScopedValue.where(X, \"hello\").run(() -> {\n    ScopedValue.where(Y, \"world\").run(() -> {\n        // nested bindings\n    });\n});",
          "compliant": "ScopedValue.where(X, \"hello\").where(Y, \"world\").run(() -> {\n    // multiple bindings in one call\n});"
        }
      ],
      "sources": [
        {
          "cluster_description": "These rules all address the same ScopedValue usage pattern - preferring chained where() calls over nested invocations when binding multiple scoped values for better readability and performance.",
          "original_ideas": [
            {
              "rule_title": "Use ScopedValue.where().where().run() for multiple bindings",
              "rule_idea": "When binding multiple scoped values simultaneously, use the fluent API ScopedValue.where().where().run() instead of nested runWhere calls for better readability and efficiency.",
              "code_examples": [
                {
                  "non_compliant": "ScopedValue.runWhere(k1, v1, () -> {\n    ScopedValue.runWhere(k2, v2, () -> {\n        operation();\n    });\n});",
                  "compliant": "ScopedValue.where(k1, v1).where(k2, v2).run(() -> operation());"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/481",
                  "source_text": "# JEP 481: Scoped Values (Third Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 23  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \n| [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2024/04/24 14:31  \nUpdated | 2025/02/25 16:32  \nIssue | [8331056](https://bugs.openjdk.org/browse/JDK-8331056)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429), became a preview API in JDK 21 via [JEP 446](https://openjdk.org/jeps/446), and was re-previewed in JDK 22 via [JEP 464](https://openjdk.org/jeps/464).\nWe here propose to re-preview the API in JDK 23 in order to gain additional experience and feedback, with one change:\n  * The type of the operation parameter of the [`ScopedValue.callWhere`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html#callWhere\\(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp\\)) method is now a new functional interface which allows the Java compiler to infer whether a checked exception might be thrown. With this change, the \n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `final` `static` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type [`ScopedValue`](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html). It is typically declared as a `final` `static` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.runWhere`, presenting a scoped value and the object to which it is to be bound. The call to `runWhere` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as an argument. During the lifetime of the `runWhere` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `runWhere` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method\nScopedValue.runWhere(NAME, <value>,\n    () -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `runWhere` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `runWhere`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.runWhere` instead of a thread-local variable's `set` method.\n```\nclass Framework {\n\n    private final static ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.runWhere(CONTEXT, context,          // (2)\n                   () -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nThe `runWhere` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `runWhere` is bound to the corresponding object for the lifetime of the `runWhere` call, so `CONTEXT.get()` in any method called from `runWhere` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `runWhere` is usable only in code called from `runWhere`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `runWhere`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.runWhere(X, \"hello\", () -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.runWhere(X, \"goodbye\", () -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/481#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.runWhere`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `runWhere` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.runWhere`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the small subset described above. While here we only present examples that use `ScopedValue<V>.runWhere(V, <value>, aRunnable)`, there are more ways to bind a scoped value. For example, the API also provides a version which returns a value and may also throw an `Exception`:\n```\ntry {\n        var result = ScopedValue.callWhere(X, \"hello\", () -> bar());\n        catch (Exception e) {\n            handleFailure(e);\n        }\n        ...\n```\n\nAdditionally, there are versions of the binding methods that can bind multiple scoped values at a call site.\nThe following example runs an operation with k1 bound (or rebound) to v1, and k2 bound (or rebound) to v2:\n```\nScopedValue.where(k1, v1).where(k2, v2).run(\n        () -> ... );\n```\n\nThis is both more efficient and much easier to read than nested invocations of `ScopedValue.runWhere`.\nThe full scoped value API can be found [here](https://cr.openjdk.org/~alanb/sv-20240517/java.base/java/lang/ScopedValue.html).\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Prefer multiple bindings over nested where calls",
              "rule_idea": "When binding multiple scoped values, use chained where() calls instead of nested invocations for better readability and performance.",
              "code_examples": [
                {
                  "non_compliant": "where(X, v).run(() -> {\n    where(Y, w).run(() -> {\n        // operation\n    });\n});",
                  "compliant": "where(X, v).where(Y, w).run(() -> {\n    // operation\n});"
                }
              ],
              "sources": [
                {
                  "url": "https://bugs.openjdk.org/browse/JDK-8352695",
                  "source_text": "### Details\n  * ** Type: **\n  * **Resolution:** Delivered \n  * ** Priority: **\n  * ** Fix Version/s:  ** [25](https://bugs.openjdk.org/issues/?jql=project+%3D+JDK+AND+fixVersion+%3D+%2225%22 \"25 JDK 25\")\n  * ** Component/s: ** [core-libs](https://bugs.openjdk.org/issues/?jql=project+%3D+JDK+AND+component+%3D+core-libs \"core-libs \")\n  * ** Labels: **\n    * [jdk25-ptt-2025-05-15](https://bugs.openjdk.org/issues/?jql=labels+%3D+jdk25-ptt-2025-05-15 \"jdk25-ptt-2025-05-15\")\n    * [loom](https://bugs.openjdk.org/issues/?jql=labels+%3D+loom \"loom\")\n\n\n  * ** Author: **\nAndrew Haley & Andrew Dinn \n  * ** JEP Type: **\nFeature \n  * ** Exposure: **\nOpen \n  * ** Scope: **\nSE \n  * ** Discussion: **\nloom dash dev at openjdk dot org \n  * ** JEP Number: **\n506 \n\n\n### Description\n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 505](https://openjdk.org/jeps/505)).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22), [JEP 481](https://openjdk.org/jeps/481) (JDK 23), and [JEP 487](https://openjdk.org/jeps/487) (JDK 24).\nWe here propose to finalize the scoped values API in JDK 25, with one small change: The `ScopedValue.orElse` method no longer accepts `null` as its argument.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls. \nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service. \n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n\n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n  |\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`. \nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 505](https://openjdk.org/jeps/505)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 505](https://openjdk.org/jeps/505#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://bugs.openjdk.org/browse/JDK-8352695#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\n    try {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site: \n```\n    where(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nWe also experimented with a version of scoped-value binding that supports the `AutoCloseable` interface, and so could be used in a `try`-with-resources construct. We ultimately rejected that idea because it is impossible to guarantee correct operation when relying on user code to invoke the `close` method at the right time. Also, even if that method is invoked as designed, by a `try`-with-resources construct, the operation may immediately fail with a `StackOverflowError`, leaving the program in an inconsistent state. Integrity, even in the case of `StackOverflowError`, is more important than the convenience of `try`-with-resources. The functional interfaces used by the `run` and `call` methods in this API allow us to guarantee integrity while still being reasonably easy to use.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n### Attachments\n### Issue Links \n\nis blocked by\n    \n[JDK-8355022](https://bugs.openjdk.org/browse/JDK-8355022) Implement JEP 506: Scoped Values\n  * Resolved\n\n\n\nrelates to\n    \n[JDK-8338456](https://bugs.openjdk.org/browse/JDK-8338456) JEP 487: Scoped Values (Fourth Preview)\n  * Closed\n\n    \n[JDK-8355720](https://bugs.openjdk.org/browse/JDK-8355720) Implement JEP 506: Scoped Values\n  * Closed\n\n\n### Activity\n## [JDK-8352695] JEP 506: Scoped Values\n  * [All](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel)\n  * Comments\n  * [History](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel)\n  * [Activity](https://bugs.openjdk.org/browse/JDK-8352695?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab)\n\n\nThere are no comments yet on this issue. \n### People \n\nAssignee: \n\n\nReporter: \n\n\nOwner: \n     Andrew Haley \n\nReviewed By: \n    \nAlan Bateman \n\nEndorsed By: \n    \nPaul Sandoz \n\nVotes:\n     0 Vote for this issue \n\nWatchers:\n     8 Start watching this issue\n### Dates \n\nCreated: \n     2025-03-24 03:10 \n\nUpdated: \n     2025-06-06 06:57 \n\nResolved: \n     2025-06-06 06:57\n"
                }
              ],
              "related_rules": []
            },
            {
              "rule_title": "Prefer multiple bindings over nested where() calls",
              "rule_idea": "When binding multiple scoped values, chain the where() calls rather than nesting them. This is more efficient and readable than nested invocations.",
              "code_examples": [
                {
                  "non_compliant": "ScopedValue.where(X, \"hello\").run(() -> {\n    ScopedValue.where(Y, \"world\").run(() -> {\n        // nested bindings\n    });\n});",
                  "compliant": "ScopedValue.where(X, \"hello\").where(Y, \"world\").run(() -> {\n    // multiple bindings in one call\n});"
                }
              ],
              "sources": [
                {
                  "url": "https://openjdk.org/jeps/487",
                  "source_text": "# JEP 487: Scoped Values (Fourth Preview)\nOwner | Andrew Haley  \n---|---  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 24  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)  \n| [JEP 506: Scoped Values](https://openjdk.org/jeps/506)  \nReviewed by | Alan Bateman, Brian Goetz  \nEndorsed by | Alan Bateman  \nCreated | 2024/08/15 16:18  \nUpdated | 2025/04/10 18:03  \nIssue | [8338456](https://bugs.openjdk.org/browse/JDK-8338456)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 480](https://openjdk.org/jeps/480)). This is a [preview API](https://openjdk.org/jeps/12).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22) and [JEP 481](https://openjdk.org/jeps/481) (JDK 23).\nWe here propose to re-preview the API once more in JDK 24 in order to gain additional experience and feedback, with one further change:\n  * We removed the `callWhere` and `runWhere` methods from the `ScopedValue` class, leaving the API completely `ScopedValue.Carrier.call` and `ScopedValue.Carrier.run` methods.\n\n\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 480](https://openjdk.org/jeps/480)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 480](https://openjdk.org/jeps/480#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/487#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
                }
              ],
              "related_rules": []
            }
          ]
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 12
      },
      "classification": "-",
      "action": " ",
      "index": 12,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Use structured concurrency APIs for scoped value inheritance",
      "rule_idea": "When creating child threads that need to inherit scoped values, use StructuredTaskScope or other structured concurrency APIs instead of legacy thread management to ensure proper inheritance and bounded lifetimes.",
      "code_examples": [
        {
          "non_compliant": "CompletableFuture.supplyAsync(() -> {\n    return CONTEXT.get(); // May not inherit\n});",
          "compliant": "try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n    var task = scope.fork(() -> CONTEXT.get());\n    scope.join();\n}"
        }
      ],
      "sources": [
        {
          "url": "https://openjdk.org/jeps/506",
          "source_text": "# JEP 506: Scoped Values\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 25  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 487: Scoped Values (Fourth Preview)](https://openjdk.org/jeps/487)  \nReviewed by | Alan Bateman  \nEndorsed by | Paul Sandoz  \nCreated | 2025/03/24 10:10  \nUpdated | 2025/06/06 13:57  \nIssue | [8352695](https://bugs.openjdk.org/browse/JDK-8352695)  \n## Summary\nIntroduce _scoped values_ , which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads ([JEP 444](https://openjdk.org/jeps/444)) and structured concurrency ([JEP 505](https://openjdk.org/jeps/505)).\n## History\nThe scoped values API was proposed for incubation by [JEP 429](https://openjdk.org/jeps/429) (JDK 20), proposed for preview by [JEP 446](https://openjdk.org/jeps/446) (JDK 21), and subsequently improved and refined by [JEP 464](https://openjdk.org/jeps/464) (JDK 22), [JEP 481](https://openjdk.org/jeps/481) (JDK 23), and [JEP 487](https://openjdk.org/jeps/487) (JDK 24).\nWe here propose to finalize the scoped values API in JDK 25, with one small change: The `ScopedValue.orElse` method no longer accepts `null` as its argument.\n## Goals\n  * _Ease of use_ \u2014 It should be easy to reason about dataflow.\n  * _Comprehensibility_ \u2014 The lifetime of shared data should be apparent from the syntactic structure of code.\n  * _Robustness_ \u2014 Data shared by a caller should be retrievable only by legitimate callees.\n  * _Performance_ \u2014 Data should be efficiently sharable across a large number of threads.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing the data as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, and so forth. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data from the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) {\n    // user code, called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    // call framework\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThe framework may maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the `FrameworkContext` object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework must be able to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to assist in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during redesign of the framework, adding it requires not only the immediate clients \u2014 those user methods that directly call framework methods or those that are directly called by it \u2014 to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method parameters. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Typically, a thread-local variable is declared as a `static final` field and its accessibility is set to `private`, allowing sharing to be restricted to instances of a single class or group of classes from a single code base.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`. The framework declares a thread-local variable, `CONTEXT` (1). When `Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n\n    private final Application application;\n\n    public Framework(Application app) { this.application = app; }\n    \n    private static final ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                    // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();              // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method parameter: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct value set in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates by using the `InheritableThreadLocal` class rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have three inherent design flaws.\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value to which it was set is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 444](https://openjdk.org/jeps/444)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived, [non-pooled](https://openjdk.org/jeps/444#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ is a container object that allows a data value to be safely and efficiently shared by a method with its direct and indirect callees within the same thread, and with child threads, without resorting to method parameters. It is a variable of type `static final` field, and its accessibility is set to `private` so that it cannot be directly accessed by code in other classes.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. A chained call of the `run` method _binds_ the scoped value, providing a copy that is specific to the current thread, and then runs the lambda expression passed as an argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get` method. After the `run` method finishes, the binding is destroyed.\n```\nstatic final ScopedValue<...> NAME = ScopedValue.newInstance();\n\n// In some method:\nScopedValue.where(NAME, <value>).run(() -> { ... NAME.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression:\n... NAME.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\nIn the remaining examples we assume that `ScopedValue.where` has been statically imported, like so:\n```\nimport static java.lang.ScopedValue.where;\n```\n\nThis allows us to shorten `ScopedValue.where(NAME, <value>).run(...)` to `where(NAME, <value>).run(...)`\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` (or `call`) method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run` or `call`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable:\n```\nclass Framework {\n\n    private static final ScopedValue<FrameworkContext> CONTEXT\n                        = ScopedValue.newInstance();    // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        where(CONTEXT, context)                         // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();                    // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n\n}\n```\n\nAt (1), the framework declares a scoped value instead of a thread-local variable. At (2), the `serve` method calls `where ... run` instead of a thread-local variable's `set` method.\nThe `run` method provides one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `run` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from, user code. We say that the `ScopedValue` object is a `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set` method means that a caller can use a scoped value to reliably communicate a value to its callees in the same thread. However, there are occasions when one of its callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n   where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, the value of `X` inside `bar` reverts to '\"hello\"'. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. After `foo` exits, `X` reverts to being unbound. This nesting guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 505](https://openjdk.org/jeps/505)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo` and `fetchOffers` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 505](https://openjdk.org/jeps/505#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>     user  = scope.fork(() -> readUserInfo());  // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve](https://openjdk.org/jeps/506#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.run`. The `Principal` will remain in scope while the child thread is running, and `scope.join` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of scoped values because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method parameters, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.run`, and then deep in the call stack, call `ScopedValue.isBound` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use. `java.text.SimpleDateFormat` objects, for example, are expensive to create and, notoriously, also mutable, so they cannot be shared between threads without synchronization. Thus giving each thread its own `SimpleDateFormat` object, via a thread-local variable that persists for the lifetime of the thread, has often been a practical approach. (Today, though, any code caching a `SimpleDateFormat` object could move to using the newer `java.util.time.DateTimeFormatter`, which can be stored in a `static final` field and shared between threads.)\n### The `ScopedValue` API\nThe full `ScopedValue` API is richer than the subset described above. Above we only showed examples that use `ScopedValue<V>.where(V, <value>).run(...)`, but the API also provides a `call` method which returns a value and may also throw an exception:\n```\ntry {\n        var result = where(X, \"hello\").call(() -> bar());\n        ... use result ...\n    catch (Exception e) {\n        handleFailure(e);\n    }\n        ...\n```\n\nAdditionally, we can bind multiple scoped values at a call site:\n```\nwhere(X, v).where(Y, w).run(() -> ... );\n```\n\nThis example runs an operation with `X` bound (or rebound) to `v`, and `Y` bound (or rebound) to `w`. This is both more efficient and easier to read than nested invocations of `ScopedValue ... where ... run`.\nThe full scoped value API can be found \n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nWe also experimented with a version of scoped-value binding that supports the `AutoCloseable` interface, and so could be used in a `try`-with-resources construct. We ultimately rejected that idea because it is impossible to guarantee correct operation when relying on user code to invoke the `close` method at the right time. Also, even if that method is invoked as designed, by a `try`-with-resources construct, the operation may immediately fail with a `StackOverflowError`, leaving the program in an inconsistent state. Integrity, even in the case of `StackOverflowError`, is more important than the convenience of `try`-with-resources. The functional interfaces used by the `run` and `call` methods in this API allow us to guarantee integrity while still being reasonably easy to use.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as \n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 13
      },
      "classification": "-",
      "action": " ",
      "index": 13,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Always call ThreadLocal.remove() to prevent memory leaks",
      "rule_idea": "When using ThreadLocal variables, always call remove() method to prevent memory leaks, especially in long-running threads or when using thread pools.",
      "code_examples": [
        {
          "non_compliant": "class DataProcessor {\n    private static final ThreadLocal<Context> context = new ThreadLocal<>();\n    \n    public void process(Data data) {\n        context.set(new Context(data));\n        doProcessing();\n        // Missing context.remove() - memory leak risk\n    }\n}",
          "compliant": "class DataProcessor {\n    private static final ThreadLocal<Context> context = new ThreadLocal<>();\n    \n    public void process(Data data) {\n        try {\n            context.set(new Context(data));\n            doProcessing();\n        } finally {\n            context.remove();\n        }\n    }\n}"
        }
      ],
      "sources": [
        {
          "url": "https://openjdk.org/jeps/429",
          "source_text": "# JEP 429: Scoped Values (Incubator)\nAuthors | Andrew Haley, Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | JDK  \nStatus | Closed / Delivered  \nRelease | 20  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot java dot net  \nRelates to | [JEP 446: Scoped Values (Preview)](https://openjdk.org/jeps/446)  \nReviewed by | Alan Bateman, Alex Buckley  \nEndorsed by | John Rose  \nCreated | 2021/03/04 11:03  \nUpdated | 2023/11/29 14:40  \nIssue | [8263012](https://bugs.openjdk.org/browse/JDK-8263012)  \n## Summary\nIntroduce _scoped values_ , which enable the sharing of immutable data within and across threads. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is an [incubating API](https://openjdk.org/jeps/11).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Treat shared data as immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nLarge Java programs typically consist of distinct and complementary components that need to share data between themselves. For example, a web framework might include a server component, implemented in the `Principal` object shared between components. The server component creates a `Principal` for each thread that handles a request, and the data access component refers to a thread's `Principal` to control access to the database.\nThe diagram below shows the framework handling two requests, each in its own thread. Request handling flows upward, from the server component (`Server.serve(...)`) to user code (`Application.handle(...)`) to the data access component (`DBAccess.open()`). The data access component determines whether the thread is permitted to access the database, as follows:\n  * In Thread 1, the `ADMIN` principal created by the server component allows database access. The dashed line indicates the principal is to be shared with the data access component, which inspects it and proceeds to call `DBAccess.newConnection()`.\n  * In Thread 2, the `GUEST` principal created by the server component does not allow database access. The data access component inspects the principal, determines that the user code must not proceed, and throws an `InvalidPrincipalException`.\n\n\n```\nThread 1                                 Thread 2\n--------                                 --------\n8. DBAccess.newConnection()              8. throw new InvalidPrincipalException()\n7. DBAccess.open() <----------+          7. DBAccess.open() <----------+\n   ...                        |             ...                        |\n   ...                  Principal(ADMIN)    ...                  Principal(GUEST)\n2. Application.handle(..)     |          2. Application.handle(..)     |\n1. Server.serve(..) ----------+          1. Server.serve(..) ----------+\n```\n\nNormally, data is shared between caller and callee by passing it as method arguments, but this is not viable for a `Principal` shared between the server component and the data access component because the server component calls untrusted user code first. We need a better way to share data from the server component to the data access component than wiring it into a cascade of untrusted method invocations.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help components share data without resorting to method arguments. A thread-local variable is a variable of type `get()` or `set(...)` methods to read or write its value. Code in one thread automatically reads and writes its incarnation, while code in another thread automatically reads and writes its own distinct incarnation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from many components.\nHere is an example of how the server component and the data access component, both running in the same request-handling thread, can use a thread-local variable to share a `Principal`. The server component first declares a thread-local variable, `PRINCIPAL` (1). When `Server.serve(...)` is executed in a request-handling thread, it writes a suitable `Principal` to the thread-local variable (2), then calls user code. If and when user code calls `DBAccess.open()`, the data access component reads the thread-local variable (3) to obtain the `Principal` of the request-handling thread. Only if the `Principal` indicates suitable permissions is database access permitted (4).\n```\nclass Server {\n    final static ThreadLocal<Principal> PRINCIPAL = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAuthorized() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        PRINCIPAL.set(principal);                                         // (2)\n        Application.handle(request, response);\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                           // (3)\n        if (!principal.canOpen()) throw new InvalidPrincipalException();\n        return newConnection(...);                                        // (4)\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `Principal` as a method argument when the server component calls user code, and when user code calls the data access component. The thread-local variable serves as a kind of hidden method argument: A thread which calls `PRINCIPAL.set(...)` in `Server.serve(...)` and then `PRINCIPAL.get()` in `DBAccess.open()` will automatically see its own incarnation of the `PRINCIPAL` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `Principal` value for the current thread.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: Any code that can call the `get()` method of a thread-local variable can call the `set(...)` method of that variable at any time. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between components. However, this can lead to spaghetti-like data flow, and to programs in which it is hard to discern which component updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one component to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's incarnation of a thread-local variable is written via the `set(...)` method, the incarnation is retained for the lifetime of the thread, or until code in the thread calls the `remove()` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because thread-local variables are mutable, and the `ThreadLocal` API requires that mutation in one thread is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set(...)` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads (`Server.serve(...)`, `Application.handle(...)`, and `DBAccess.open()` would all execute in a new virtual thread for each incoming request.\nIt would obviously be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has mutable thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain immutable and inheritable per-thread data for thousands or millions of virtual threads. Because these per-thread variables would be immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between components in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many components.\nLike a thread-local variable, a scoped value has multiple incarnations, one per thread. The particular incarnation that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once and is then immutable, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where(...)`, presenting a scoped value and the object to which it is to be bound. The call to `run(...)` _binds_ the scoped value, providing an incarnation that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run(...)` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run(...)` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe syntactic structure of the code delineates the period of time when a thread can read its incarnation of a scoped value. This bounded lifetime, combined with immutability, greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set(...)` method that lets faraway code change the scoped value at any time. Immutability also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. This is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run(...)` method produces an incarnation of V that is usable by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run(...)`. The unfolding execution of those methods defines a dynamic scope; the incarnation is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the server component declares a scoped value instead of a thread-local variable. At (2), the server component calls `ScopedValue.where(...)` and `run(...)` instead of a thread-local variable's `set(...)` method.\n```\nclass Server {\n    final static ScopedValue<Principal> PRINCIPAL =  ScopedValue.newInstance(); // (1)\n\n    void serve(Request request, Response response) {\n        var level     = (request.isAdmin() ? ADMIN : GUEST);\n        var principal = new Principal(level);\n        ScopedValue.where(PRINCIPAL, principal)                            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (3)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\nTogether, `where(...)` and `run(...)` provide one-way sharing of data from the server component to the data access component. The scoped value passed to `where(...)` is bound to the corresponding object for the lifetime of the `run(...)` call, so `PRINCIPAL.get()` in any method called from `run(...)` will read that value. Accordingly, when `Server.serve(...)` calls user code, and user code calls `DBAccess.open()`, the value read from the scoped value (3) is the value written by `Server.serve(...)` earlier in the thread.\nThe binding established by `run(...)` is usable only in code called from `run(...)`. If `PRINCIPAL.get()` appeared in `Server.serve(...)` after the call to `run(...)`, an exception would be thrown because `PRINCIPAL` is no longer bound in the thread.\n### Rebinding scoped values\nThe immutability of scoped values means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees in the thread. The `ScopedValue` API allows a new binding to be established for nested calls.\nAs an example, consider a third component of the web framework: a logging component with a method `void log(Supplier<String> formatter)`. User code passes a lambda expression to the `log(...)` method; if logging is enabled, the method calls `formatter.get()` to evaluate the lambda expression and then prints the result. Although the user code may have permission to access the database, the lambda expression should not, since it only needs to format text. Accordingly, the scoped value that was initially bound in `Server.serve(...)` should be rebound to a guest `Principal` for the lifetime of `formatter.get()`:\n```\n8. InvalidPrincipalException()\n7. DBAccess.open() <--------------------------+  X---------+\n   ...                                        |            |\n   ...                                  Principal(GUEST)   |\n4. Supplier.get()                             |            |\n3. Logger.log(() -> { DBAccess.open(); }) ----+      Principal(ADMIN)\n2. Application.handle(..)                                  |\n1. Server.serve(..) ---------------------------------------+\n```\n\nHere is the code for `log(...)` with rebinding. It obtains a guest `Principal` (1) and passes it as the new binding for the scoped value `PRINCIPAL` (2). For the lifetime of the invocation of `call` (3), `PRINCIPAL.get()` will read this new value. Thus, if the user code passes a malicious lambda expression to `log(...)` that performs `DBAccess.open()`, the check in `DBAccess.open()` will read the guest `Principal` from `PRINCIPAL` and throw an `InvalidPrincipalException`.\n```\nclass Logger {\n    void log(Supplier<String> formatter) {\n        if (loggingEnabled) {\n            var guest = Principal.createGuest();                      // (1)\n            var message = ScopedValue.where(Server.PRINCIPAL, guest)  // (2)\n                                     .call(() -> formatter.get());    // (3)\n            write(logFile, \"%s %s\".format(timeStamp(), message));\n        }\n    }\n}\n```\n\n(We here use `call(...)` instead of `run(...)` to invoke the formatter because the result of the lambda expression is needed.) The syntactic structure of `where(...)` and `call(...)` means that the rebinding is only visible in the nested dynamic scope introduced by `call(...)`. The body of `log(...)` cannot change the binding seen by that method itself but can change the binding seen by its callees, such as the `formatter.get(...)` method. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread can execute framework code from the server component, then user code from the application developer, then more framework code from the data access component. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nData shared by a component running in the request-handling thread needs to be available to components running in child threads. Otherwise, when user code running in a child thread calls the data access component, that component \u2014 now also running in the child thread \u2014 will be unable to check the `Principal` shared by the server component running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API (`StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code, in a variant of the `Application.handle(...)` method called from `Server.serve(...)`. The user code calls `StructuredTaskScope.fork(...)` (1, 2) to run the `findUser()` and `fetchOrder()` methods concurrently, in their own virtual threads. Each method calls the data access component (3), which as before consults the scoped value `PRINCIPAL` (4). Further details of the user code are not discussed here; see \n```\nclass Application {\n    Response handle() throws ExecutionException, InterruptedException {\n        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n            Future<String>  user  = scope.fork(() -> findUser());          // (1)\n            Future<Integer> order = scope.fork(() -> fetchOrder());        // (2)\n            scope.join().throwIfFailed();  // Wait for both forks\n            return new Response(user.resultNow(), order.resultNow());\n        }\n    }\n\n    String findUser() {\n        ... DBAccess.open() ...                                            // (3)\n    }\n}\n\nclass DBAccess {\n    DBConnection open() {\n        var principal = Server.PRINCIPAL.get();                            // (4)\n        if (!principal.canOpen()) throw new  InvalidPrincipalException();\n        return newConnection(...);\n    }\n}\n```\n\n`StructuredTaskScope.fork(...)` ensures that the binding of the scoped value `PRINCIPAL` made in the request-handling thread \u2014 [when Server.serve(...) called ScopedValue.where(...)](https://openjdk.org/jeps/429#Web-framework-example-ScopedValue-code) \u2014 is automatically visible to `PRINCIPAL.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                           Thread 2\n--------                           --------\n                                   8. DBAccess.newConnection()\n                                   7. DBAccess.open() <----------+\n                                   ...                           |\n                                   ...                     Principal(ADMIN)\n                                   4. Application.findUser()     |\n3. StructuredTaskScope.fork(..)                                  |\n2. Application.handle(..)                                        |\n1. Server.serve(..) ---------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run(...)` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where(...)` and `run(...)`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set(...)` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 14
      },
      "classification": "-",
      "action": " ",
      "index": 14,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Use ScopedValue.isBound() before calling get() for optional values",
      "rule_idea": "When a ScopedValue might not be bound in the current scope, use ScopedValue.isBound() to check before calling get() to avoid exceptions, especially useful for re-entrant code detection.",
      "code_examples": [
        {
          "non_compliant": "private static final ScopedValue<Integer> DEPTH = ScopedValue.newInstance();\n\nvoid checkRecursion() {\n    int currentDepth = DEPTH.get(); // May throw if not bound\n}",
          "compliant": "private static final ScopedValue<Integer> DEPTH = ScopedValue.newInstance();\n\nvoid checkRecursion() {\n    if (DEPTH.isBound()) {\n        int currentDepth = DEPTH.get();\n    }\n}"
        }
      ],
      "sources": [
        {
          "url": "https://openjdk.org/jeps/446",
          "source_text": "# JEP 446: Scoped Values (Preview)\nAuthor | Andrew Haley & Andrew Dinn  \n---|---  \nOwner | Andrew Haley  \nType | Feature  \nScope | SE  \nStatus | Closed / Delivered  \nRelease | 21  \nComponent | core-libs  \nDiscussion | loom dash dev at openjdk dot org  \nRelates to | [JEP 429: Scoped Values (Incubator)](https://openjdk.org/jeps/429)  \n| [JEP 464: Scoped Values (Second Preview)](https://openjdk.org/jeps/464)  \nReviewed by | Alan Bateman, Mark Reinhold  \nEndorsed by | Brian Goetz  \nCreated | 2023/03/16 16:01  \nUpdated | 2023/11/29 14:41  \nIssue | [8304357](https://bugs.openjdk.org/browse/JDK-8304357)  \n## Summary\nIntroduce _scoped values_ , values that may be safely and efficiently shared to methods without using method parameters. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is a [preview API](https://openjdk.org/jeps/12).\nIn effect, a scoped value is an _implicit method parameter_. It is \"as if\" every method in a sequence of calls has an additional, invisible, parameter. None of the methods declare this parameter and only the methods that have access to the scoped value object can access its value (the data). Scoped values make it possible to pass data securely from a caller to a faraway callee through a sequence of intermediate methods that do not declare a parameter for the data and have no access to the data.\n## History\nScoped Values incubated in JDK 20 via [JEP 429](https://openjdk.org/jeps/429). In JDK 21 this feature is no longer incubating; instead, it is a [preview API](https://openjdk.org/jeps/12).\n## Goals\n  * _Ease of use_ \u2014 Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow.\n  * _Comprehensibility_ \u2014 Make the lifetime of shared data visible from the syntactic structure of code.\n  * _Robustness_ \u2014 Ensure that data shared by a caller can be retrieved only by legitimate callees.\n  * _Performance_ \u2014 Allow shared data to be immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.\n\n\n## Non-Goals\n  * It is not a goal to change the Java programming language.\n  * It is not a goal to require migration away from thread-local variables, or to deprecate the existing `ThreadLocal` API.\n\n\n## Motivation\nJava applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls.\nMost methods allow a caller to pass data to a method by passing them as parameters. When method `A` wants method `B` to do some work for it, it invokes `B` with the appropriate parameters, and `B` may pass some of those parameters to `C`, etc. `B` may have to include in its parameter list not only the things `B` directly needs but also the things `B` has to pass to `C`. For example, if `B` is going to set up and execute a database call, it might want a Connection passed in, even if `B` is not going to use the Connection directly.\nMost of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call.\n### An example\nIt is a common pattern in large Java programs to transfer control from one component (a \"framework\") to another (\"application code\") and then back. For example, a web framework could accept incoming HTTP requests and then call an application handler to handle it. The application handler may then call the framework to read data to the database or to call some other HTTP service.\n```\n@Override\npublic void handle(Request request, Response response) { // user code; called by framework\n    ...\n    var userInfo = readUserInfo();\n    ...\n}\n\nprivate UserInfo readUserInfo() {\n    return (UserInfo)framework.readKey(\"userInfo\", context);// call framework\n}\n```\n\nThe framework may need to maintain a `FrameworkContext` object, containing the authenticated user ID, the transaction ID, etc., and associate it with the current transaction. All framework operations use the context object, but it's unused by (and irrelevant to) user code.\nIn effect, the framework wishes to communicate its internal context from its `serve` method (which calls the user's `handle` method) to its `readKey` method:\n```\n4. Framework.readKey <--------+ use context\n3. Application.readUserInfo   |\n2. Application.handle         |\n1. Framework.serve  ----------+ create context\n```\n\nThe simplest way to do this is by passing the object as an argument to all methods in the call chain:\n```\n@Override\nvoid handle(Request request, Response response, FrameworkContext context) {\n    ...\n    var userInfo = readUserInfo(context);\n    ...\n}\n\nprivate UserInfo readUserInfo(FrameworkContext context) {\n    return (UserInfo)framework.readKey(\"userInfo\", context);\n}\n```\n\nThere is no way for the user code to _assist_ in the proper handling of the context object. At worst, it could interfere by mixing up contexts; at best it is burdened with the need to add another parameter to all methods that may end up calling back into the framework. If the need to pass a context emerges during re-design of the framework, adding it requires not only the immediate clients -- those user methods that directly call framework methods or those that are directly called by it -- to change their signature, but all intermediate methods as well, even though the context is an internal implementation detail of the framework and user code should not interact with it.\n### Thread-local variables for sharing\nDevelopers have traditionally used _thread-local variables_ , introduced in Java 1.2, to help share data between methods on the call stack without resorting to method arguments. A thread-local variable is a variable of type `get` or `set` methods to read or write its value. Code in one thread automatically reads and writes its value, while code in another thread automatically reads and writes its own distinct instantiation. Typically, a thread-local variable is declared as a `final` `static` field so it can easily be reached from different methods, and `private` so that it cannot be directly accessed by client (user) code.\nHere is an example of how the two framework methods, both running in the same request-handling thread, can use a thread-local variable to share a `FrameworkContext`.\nThe framework declares a thread-local variable, `CONTEXT` (1). When`Framework.serve` is executed in a request-handling thread, it writes a suitable `FrameworkContext` to the thread-local variable (2), then calls user code. If and when user code calls `Framework.readKey`, that method reads the thread-local variable (3) to obtain the `FrameworkContext` of the request-handling thread.\n```\npublic class Framework {\n    private final Application application;\n    public Framework(Application app) { this.application = app; }\n    \n    private final static ThreadLocal<FrameworkContext> CONTEXT \n                       = new ThreadLocal<>();  // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        CONTEXT.set(context);                  // (2)\n        Application.handle(request, response);\n    }\n\n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n}\n```\n\nUsing a thread-local variable avoids the need to pass a `FrameworkContext` as a method argument when the framework calls user code, and when user code calls a framework method back. The thread-local variable serves as a hidden method argument: A thread that calls `CONTEXT.set` in `Framework.serve` and then `CONTEXT.get()` in `Framework.readKey` will automatically see its own local copy of the `CONTEXT` variable. In effect, the `ThreadLocal` field serves as a key that is used to look up a `FrameworkContext` value for the current thread.\nWhile `ThreadLocals` have a distinct instantiation in each thread, the value that is currently set in one thread can be automatically inherited by another thread that the current thread creates if the `InheritableThreadLocal` class is used rather than the `ThreadLocal` class.\n### Problems with thread-local variables\nUnfortunately, thread-local variables have numerous design flaws that are impossible to avoid:\n  * _Unconstrained mutability_ \u2014 Every thread-local variable is mutable: any code that can call the `get()` method of a thread-local variable can call the `set` method of that variable at any time. This is still true even if an object in a thread-local variable is immutable due to every one of its fields being declared final. The `ThreadLocal` API allows this in order to support a fully general model of communication, where data can flow in any direction between methods. This can lead to spaghetti-like data flow, and to programs in which it is hard to discern which method updates shared state and in what order. The more common need, shown in the example above, is a simple one-way transmission of data from one method to others.\n  * _Unbounded lifetime_ \u2014 Once a thread's copy of a thread-local variable is set via the `set` method, the value [to which it was set] is retained for the lifetime of the thread, or until code in the thread calls the `remove` method. Unfortunately, developers often forget to call `remove()`, so per-thread data is often retained for longer than necessary. In particular, if a thread pool is used, the value of a thread-local variable set in one task could, if not properly cleared, accidentally leak into an unrelated task, potentially leading to dangerous security vulnerabilities. In addition, for programs that rely on the unconstrained mutability of thread-local variables, there may be no clear point at which it is safe for a thread to call `remove()`; this can cause a long-term memory leak, since per-thread data will not be garbage-collected until the thread exits. It would be better if the writing and reading of per-thread data occurred in a bounded period during execution of the thread, avoiding the possibility of leaks.\n  * _Expensive inheritance_ \u2014 The overhead of thread-local variables may be worse when using large numbers of threads, because thread-local variables of a parent thread can be inherited by child threads. (A thread-local variable is not, in fact, local to one thread.) When a developer chooses to create a child thread that inherits thread-local variables, the child thread has to allocate storage for every thread-local variable previously written in the parent thread. This can add significant memory footprint. Child threads cannot share the storage used by the parent thread because the `ThreadLocal` API requires that changing a thread's copy of the thread-local variable is not seen in other threads. This is unfortunate, because in practice child threads rarely call the `set` method on their inherited thread-local variables.\n\n\n### Toward lightweight sharing\nThe problems of thread-local variables have become more pressing with the availability of virtual threads ([JEP 425](https://openjdk.org/jeps/425)). Virtual threads are lightweight threads implemented by the JDK. Many virtual threads share the same operating-system thread, allowing for very large numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior. This means that a web framework can dedicate a new virtual thread to the task of handling a request and still be able to process thousands or millions of requests at once. In the ongoing example, the methods `Framework.serve`, `Application.handle`, and `Framework.readKey` would all execute in a new virtual thread for each incoming request.\nIt would be useful for these methods to be able to share data whether they execute in virtual threads or traditional platform threads. Because virtual threads are instances of `Thread`, a virtual thread can have thread-local variables; in fact, the short-lived [non-pooled](https://openjdk.org/jeps/425#Do-not-pool-virtual-threads) nature of virtual threads makes the problem of long-term memory leaks, mentioned above, less acute. (Calling a thread-local variable's `remove()` method is unnecessary when a thread terminates quickly, since termination automatically removes its thread-local variables.) However, if each of a million virtual threads has its own copy of thread-local variables, the memory footprint may be significant.\nIn summary, thread-local variables have more complexity than is usually needed for sharing data, and significant costs that cannot be avoided. The Java Platform should provide a way to maintain inheritable per-thread data for thousands or millions of virtual threads. If these per-thread variables were immutable, their data could be shared by child threads efficiently. Further, the lifetime of these per-thread variables should be bounded: Any data shared via a per-thread variable should become unusable once the method that initially shared the data is finished.\n## Description\nA _scoped value_ allows data to be safely and efficiently shared between methods in a large program without resorting to method arguments. It is a variable of type `final` `static` field so it can easily be reached from many methods.\nLike a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread.\nA scoped value is used as shown below. Some code calls `ScopedValue.where`, presenting a scoped value and the object to which it is to be bound. The call to `run` _binds_ the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the `run` call, the lambda expression, or any method called directly or indirectly from that expression, can read the scoped value via the value\u2019s `get()` method. After the `run` method finishes, the binding is destroyed.\n```\nfinal static ScopedValue<...> V = ScopedValue.newInstance();\n\n// In some method\nScopedValue.where(V, <value>)\n           .run(() -> { ... V.get() ... call methods ... });\n\n// In a method called directly or indirectly from the lambda expression\n... V.get() ...\n```\n\nThe structure of the code delineates the period of time when a thread can read its copy of a scoped value. This bounded lifetime greatly simplifies reasoning about thread behavior. The one-way transmission of data from caller to callees \u2014 both direct and indirect \u2014 is obvious at a glance. There is no `set` method that lets faraway code change the scoped value at any time. This also helps performance: Reading a scoped value with `get()` is often as fast as reading a local variable, regardless of the stack distance between caller and callee.\n### The meaning of \"scoped\"\nThe _scope_ of a thing is the space in which it lives \u2014 the extent or range in which it can be used. For example, in the Java programming language, the scope of a variable declaration is the space within the program text where it is legal to refer to the variable with a simple name (_lexical scope_ or _static scope_ , since the space where the variable is in scope can be understood statically by looking for `{` and `}` characters in the program text.\nAnother kind of scope is called _dynamic scope_. The dynamic scope of a thing refers to the parts of a program that can use the thing as the program executes. If method `a` calls method `b` that, in turn, calls method `c`, the execution lifetime of `c` is contained within the execution of `b`, which is contained in that of `a`, even though the three methods are distinct code units:\n```\n|\n  |   +\u2013\u2013 a\n  |   |\n  |   |  +\u2013\u2013 b\n  |   |  |\nTIME  |  |  +\u2013\u2013 c\n  |   |  |  |\n  |   |  |  |__\n  |   |  |\n  |   |  |__\n  |   |\n  |   |__\n  |\n  v\n```\n\nThis is the concept to which _scoped value_ appeals, because binding a scoped value V in a `run` method produces a value that is accessible by certain parts of the program as it executes, namely the methods invoked directly or indirectly by `run`.\nThe unfolding execution of those methods defines a dynamic scope; the binding is in scope during the execution of those methods, and nowhere else.\n### Web framework example with scoped values\nThe framework code shown earlier can easily be rewritten to use a scoped value instead of a thread-local variable. At (1), the framework declares a scoped value instead of a thread-local variable. At (2), the serve method calls `ScopedValue.where` and `run` instead of a thread-local variable's `set` method.\n```\nclass Frameowrk {\n    private final static ScopedValue<FrameworkContext> CONTEXT \n                        = ScopedValue.newInstance();   // (1)\n\n    void serve(Request request, Response response) {\n        var context = createContext(request);\n        ScopedValue.where(CONTEXT, context)            // (2)\n                   .run(() -> Application.handle(request, response));\n    }\n    \n    public PersistedObject readKey(String key) {\n        var context = CONTEXT.get();            // (3)\n        var db = getDBConnection(context);\n        db.readKey(key);\n    }\n    \n    ...\n}\n```\n\nTogether, `where` and `run` provide one-way sharing of data from the `serve` method to the `readKey` method. The scoped value passed to `where` is bound to the corresponding object for the lifetime of the `run` call, so `CONTEXT.get()` in any method called from `run` will read that value. Accordingly, when `Framework.serve` calls user code, and user code calls `Framework.readKey`, the value read from the scoped value (3) is the value written by `Framework.serve` earlier in the thread.\nThe binding established by `run` is usable only in code called from `run`. If `CONTEXT.get()` appeared in `Framework.serve` after the call to `run`, an exception would be thrown because `CONTEXT` is no longer bound in the thread.\nAs before, the framework relies on Java's access control to restrict access to its internal data: The `CONTEXT` field has private access, which allows the framework to share information internally between its two methods. That information is inaccessible to, and hidden from user code. We say that the `ScopedValue` object is a _capability_ object that gives code with permissions to access it the ability to bind or read the value. Often the `ScopedValue` will have `private` access, but sometimes it may have `protected` or package access to allow multiple cooperating classes to read and bind the value.\n### Rebinding scoped values\nThat scoped values have no `set()` method means that a caller can use a scoped value to reliably communicate a constant value to its callees in the same thread. However, there are occasions when one of the callees might need to use the same scoped value to communicate a different value to its own callees. The `ScopedValue` API allows a new nested binding to be established for subsequent calls:\n```\nprivate static final ScopedValue<String> X = ScopedValue.newInstance();\n\nvoid foo() {\n    ScopedValue.where(X, \"hello\").run(() -> bar());\n}\n\nvoid bar() {\n    System.out.println(X.get()); // prints hello\n    ScopedValue.where(X, \"goodbye\").run(() -> baz());\n    System.out.println(X.get()); // prints hello\n}\n\nvoid baz() {\n    System.out.println(X.get()); // prints goodbye\n}\n```\n\n`bar` reads the value of `X` to be `\"hello\"`, as that is the binding in the scope established in `foo`. But then `bar` establishes a nested scope to run `baz` where `X` is bound to `goodbye`.\nNotice how the `\"goodbye\"` binding is in effect only inside the nested scope. Once `baz` returns, `bar` sees the `\"hello\"` binding. The body of `bar` cannot change the binding seen by that method itself but can change the binding seen by its callees. This guarantees a bounded lifetime for sharing of the new value.\n### Inheriting scoped values\nThe web framework example dedicates a thread to handling each request, so the same thread executes some framework code, then user code from the application developer, then more framework code to access the database. However, user code can exploit the lightweight nature of virtual threads by creating its own virtual threads and running its own code in them. These virtual threads will be child threads of the request-handling thread.\nContext data shared by a code running in the request-handling thread needs to be available to code running in child threads. Otherwise, when user code running in a child thread calls a framework method it will be unable to access the `FrameworkContext` created by the framework code running in the request-handling thread. To enable cross-thread sharing, scoped values can be inherited by child threads.\nThe preferred mechanism for user code to create virtual threads is the Structured Concurrency API ([JEP 428](https://openjdk.org/jeps/428)), specifically the class `StructuredTaskScope`. Code in a child thread can use bindings established for a scoped value in the parent thread with minimal overhead. Unlike with thread-local variables, there is no copying of a parent thread's scoped value bindings to the child thread.\nHere is an example of scoped value inheritance occurring behind the scenes in user code. The `Server.serve` method binds `CONTEXT` and calls `Application.handle` just as before. However, the user code in `Application.handle` calls run the `readUserInfo()` and `fetchOffers()` methods concurrently, each in its own virtual threads, using `StructuredTaskScope.fork` (1, 2). Each method may use `Framework.readKey` which, as before, consults the scoped value `CONTEXT` (4). Further details of the user code are not discussed here; see [JEP 428](https://openjdk.org/jeps/428#Description) for further information.\n```\n@Override\npublic Response handle(Request request, Response response) {\n      try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier<UserInfo>    user   = scope.fork(() -> readUserInfo()); // (1)\n          Supplier<List<Offer>> offers = scope.fork(() -> fetchOffers());   // (2)\n          scope.join().throwIfFailed();  // Wait for both forks\n          return new Response(user.get(), order.get());\n      } catch (Exception ex) {\n          reportError(response, ex);\n      }\n}\n```\n\n`StructuredTaskScope.fork` ensures that the binding of the scoped value `CONTEXT` made in the request-handling thread \u2014 [in Framework.serve(...)](https://openjdk.org/jeps/446#Web-framework-example-ScopedValue-code) \u2014 is read by `CONTEXT.get()` in the child thread. The following diagram shows how the dynamic scope of the binding is extended to all methods executed in the child thread:\n```\nThread 1                        Thread 2\n--------                        --------   \n                                5. Framework.readKey <----------+\n                                                                |\n                                                              CONTEXT\n                                4. Application.readUserInfo     |\n3. StructuredTaskScope.fork                                     |\n2. Application.handle                                           |\n1. Server.serve     --------------------------------------------+\n```\n\nThe fork/join model offered by `StructuredTaskScope` means that the dynamic scope of the binding is still bounded by the lifetime of the call to `ScopedValue.where(...).run(...)`. The `Principal` will remain in scope while the child thread is running, and `scope.join()` ensures that child threads terminate before `run` can return, destroying the binding. This avoids the problem of unbounded lifetimes seen when using thread-local variables. Legacy thread management classes such as `ForkJoinPool` do not support inheritance of ScopedValues because they cannot guarantee that a child thread forked from some parent thread scope will exit before the parent leaves that scope.\n### Migrating to scoped values\nScoped values are likely to be useful and preferable in many scenarios where thread-local variables are used today. Beyond serving as hidden method arguments, scoped values may assist with:\n  * _Re-entrant code_ \u2014 Sometimes it is desirable to detect recursion, perhaps because a framework is not re-entrant or because recursion must be limited in some way. A scoped value provides a way to do this: Set it up as usual, with `ScopedValue.where` and `run`, and then deep in the call stack, call `ScopedValue.isBound()` to check if it has a binding for the current thread. More elaborately, the scoped value can model a recursion counter by being repeatedly rebound.\n  * _Nested transactions_ \u2014 Detecting recursion can also be useful in the case of flattened transactions: Any transaction started while a transaction is in progress becomes part of the outermost transaction.\n  * _Graphics contexts_ \u2014 Another example occurs in graphics, where there is often a drawing context to be shared between parts of the program. Scoped values, because of their automatic cleanup and re-entrancy, are better suited to this than thread-local variables.\n\n\nIn general, we advise migration to scoped values when the purpose of a thread-local variable aligns with the goal of a scoped value: one-way transmission of unchanging data. If a codebase uses thread-local variables in a two-way fashion \u2014 where a callee deep in the call stack transmits data to a faraway caller via `ThreadLocal.set` \u2014 or in a completely unstructured fashion, then migration is not an option.\nThere are a few scenarios that favor thread-local variables. An example is caching objects that are expensive to create and use, such as instances of `java.text.DateFormat`. Notoriously, a `DateFormat` object is mutable, so it cannot be shared between threads without synchronization. Giving each thread its own `DateFormat` object, via a thread-local variable that persists for the lifetime of the thread, is often a practical approach.\n## Alternatives\nIt is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance.\nWe experimented with a modified version of `ThreadLocal` that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns `UnsupportedOperationException` for much of its core functionality, or both. It is better, therefore, not to modify `ThreadLocal` but to introduce scoped values as an entirely separate concept.\nScoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads.\n[](https://openjdk.org/)\n[Installing](https://openjdk.org/install/)\n[Contributing](https://openjdk.org/guide/#contributing-to-an-openjdk-project)\n[Sponsoring](https://openjdk.org/guide/#reviewing-and-sponsoring-a-change)\n[Developers' Guide](https://openjdk.org/guide/)\n[Vulnerabilities](https://openjdk.org/groups/vulnerability/report)\n[Mailing lists](https://mail.openjdk.org)\n[Wiki](https://wiki.openjdk.org) \u00b7 [IRC](https://openjdk.org/irc)\n[Bylaws](https://openjdk.org/bylaws) \u00b7 [Census](https://openjdk.org/census)\n[Legal](https://openjdk.org/legal/)\n[**Workshop**](https://openjdk.org/workshop)\n[**JEP Process**](https://openjdk.org/jeps/0)\nSource code\n[Mercurial](https://hg.openjdk.org)\nTools\n[jtreg harness](https://openjdk.org/jtreg/)\nGroups\n[(overview)](https://openjdk.org/groups/)\n[Adoption](https://openjdk.org/groups/adoption)\n[Build](https://openjdk.org/groups/build)\n[Client Libraries](https://openjdk.org/groups/client-libs)\n[Compatibility & Specification Review](https://openjdk.org/groups/csr)\n[Compiler](https://openjdk.org/groups/compiler)\n[Conformance](https://openjdk.org/groups/conformance)\n[Core Libraries](https://openjdk.org/groups/core-libs)\n[Governing Board](https://openjdk.org/groups/gb)\n[HotSpot](https://openjdk.org/groups/hotspot)\n[IDE Tooling & Support](https://openjdk.org/groups/ide-support)\n[Internationalization](https://openjdk.org/groups/i18n)\n[JMX](https://openjdk.org/groups/jmx)\n[Members](https://openjdk.org/groups/members)\n[Networking](https://openjdk.org/groups/net)\n[Porters](https://openjdk.org/groups/porters)\n[Quality](https://openjdk.org/groups/quality)\n[Security](https://openjdk.org/groups/security)\n[Serviceability](https://openjdk.org/groups/serviceability)\n[Vulnerability](https://openjdk.org/groups/vulnerability)\n[Web](https://openjdk.org/groups/web)\nProjects\n([overview](https://openjdk.org/projects/), [archive](https://openjdk.org/projects/archive))\n[Amber](https://openjdk.org/projects/amber)\n[Babylon](https://openjdk.org/projects/babylon)\n[CRaC](https://openjdk.org/projects/crac)\n[Code Tools](https://openjdk.org/projects/code-tools)\n[Coin](https://openjdk.org/projects/coin)\n[Common VM Interface](https://openjdk.org/projects/cvmi)\n[Developers' Guide](https://openjdk.org/projects/guide)\n[Device I/O](https://openjdk.org/projects/dio)\n[Duke](https://openjdk.org/projects/duke)\n[Galahad](https://openjdk.org/projects/galahad)\n[Graal](https://openjdk.org/projects/graal)\n[IcedTea](https://openjdk.org/projects/icedtea)\n[JDK 8 Updates](https://openjdk.org/projects/jdk8u)\n[JDK 9](https://openjdk.org/projects/jdk9)\n[JDK](https://openjdk.org/projects/jdk) (\u2026, [24](https://openjdk.org/projects/jdk/24), [25](https://openjdk.org/projects/jdk/25), [26](https://openjdk.org/projects/jdk/26))\n[JDK Updates](https://openjdk.org/projects/jdk-updates)\n[JMC](https://openjdk.org/projects/jmc)\n[Jigsaw](https://openjdk.org/projects/jigsaw)\n[Kona](https://openjdk.org/projects/kona)\n[Lanai](https://openjdk.org/projects/lanai)\n[Leyden](https://openjdk.org/projects/leyden)\n[Lilliput](https://openjdk.org/projects/lilliput)\n[Locale Enhancement](https://openjdk.org/projects/locale-enhancement)\n[Loom](https://openjdk.org/projects/loom)\n[Memory Model Update](https://openjdk.org/projects/jmm)\n[Metropolis](https://openjdk.org/projects/metropolis)\n[Multi-Language VM](https://openjdk.org/projects/mlvm)\n[Nashorn](https://openjdk.org/projects/nashorn)\n[New I/O](https://openjdk.org/projects/nio)\n[OpenJFX](https://openjdk.org/projects/openjfx)\n[Panama](https://openjdk.org/projects/panama)\n[Penrose](https://openjdk.org/projects/penrose)\n[Port: AArch32](https://openjdk.org/projects/aarch32-port)\n[Port: AArch64](https://openjdk.org/projects/aarch64-port)\n[Port: BSD](https://openjdk.org/projects/bsd-port)\n[Port: Haiku](https://openjdk.org/projects/haiku-port)\n[Port: Mac OS X](https://openjdk.org/projects/macosx-port)\n[Port: MIPS](https://openjdk.org/projects/mips-port)\n[Port: Mobile](https://openjdk.org/projects/mobile)\n[Port: PowerPC/AIX](https://openjdk.org/projects/ppc-aix-port)\n[Port: RISC-V](https://openjdk.org/projects/riscv-port)\n[Port: s390x](https://openjdk.org/projects/s390x-port)\n[SCTP](https://openjdk.org/projects/sctp)\n[Shenandoah](https://openjdk.org/projects/shenandoah)\n[Skara](https://openjdk.org/projects/skara)\n[Sumatra](https://openjdk.org/projects/sumatra)\n[Tsan](https://openjdk.org/projects/tsan)\n[Valhalla](https://openjdk.org/projects/valhalla)\n[Verona](https://openjdk.org/projects/verona)\n[VisualVM](https://openjdk.org/projects/visualvm)\n[Wakefield](https://openjdk.org/projects/wakefield)\n[Zero](https://openjdk.org/projects/zero)\n[ZGC](https://openjdk.org/projects/zgc)\n\u00a9 2025 Oracle Corporation and/or its affiliates   \n[Terms of Use](https://openjdk.org/legal/tou/) \u00b7 License: [GPLv2](https://openjdk.org/legal/gplv2+ce.html) \u00b7 [Trademarks](https://openjdk.org/legal/openjdk-trademark-notice.html)\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 15
      },
      "classification": "-",
      "action": " ",
      "index": 15,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "Virtual thread tasks must be created within ScopedValue binding scope",
      "rule_idea": "When using ScopedValues with Virtual Threads, the task submitted to the executor must be created inside the ScopedValue binding scope to retain the binding. Simply submitting a task from within the scope is insufficient.",
      "code_examples": [
        {
          "non_compliant": "static final ScopedValue<String> USER = ScopedValue.newInstance();\n\npublic void submitTask(ExecutorService executor) {\n    Runnable task = () -> {\n        System.out.println(\"User: \" + USER.get()); // Will fail\n    };\n    \n    ScopedValue.where(USER, \"Alice\").run(() -> {\n        executor.submit(task); // Task created outside scope\n    });\n}",
          "compliant": "static final ScopedValue<String> USER = ScopedValue.newInstance();\n\npublic void submitTask(ExecutorService executor) {\n    ScopedValue.where(USER, \"Alice\").run(() -> {\n        executor.submit(() -> {\n            System.out.println(\"User: \" + USER.get()); // Task created within scope\n        });\n    });\n}"
        }
      ],
      "sources": [
        {
          "url": "https://www.baeldung.com/java-25-features",
          "source_text": "## 1. Overview[](https://www.baeldung.com/java-25-features#overview)\nJava 25 is almost out! The new long-term-support(LTS) release, scheduled for September 2025, introduces a comprehensive set of enhancements across the Java language, standard libraries, APIs, and runtime.\nIn this tutorial, we\u2019ll explore all the new features and changes introduced in Java 25 as of June 2025. Let\u2019s understand them with a simple code sample and a detailed explanation.\n## 2. Language and Compiler Features[](https://www.baeldung.com/java-25-features#language-and-compiler-features)\nJava 25 introduces a set of language and compiler enhancements aimed at making the language more expressive and concise. These features enhance the developer experience in both everyday tasks and advanced, modular scenarios.\n### 2.1. Primitive Types in Patterns (JEP 507 \u2013 Third Preview)[](https://www.baeldung.com/java-25-features#1-primitive-types-in-patterns-jep-507--third-preview)\nNow, pattern matching can handle primitive types in _switch_ and _instanceof_ statements. For instance:\n```\nstatic void test(Object obj) {\n    if (obj instanceof int i) {\n        System.out.println(\"It's an int: \" + i);\n    }\n}Copy\n```\n\nJEP 507 introduces primitive types into Java\u2019s pattern-matching framework, making such expressions more straightforward and reducing boilerplate code. This JEP is part of a broader effort to unify type patterns across the language.\n### 2.2. Module Import Declarations (JEP 511 \u2013 Preview)[](https://www.baeldung.com/java-25-features#2-module-import-declarations-jep-511--preview)\nJEP 511 introduces Module Import Declarations, allowing us to use modules to declare their dependencies via _import_ statements, improving modular readability. Traditionally, dependencies in a module were only declared in the _module-info.java_ descriptor using _requires_ directives.**JEP 511 introduces a way to declare module dependencies using the _import module_ statement at the top of a Java file, similar to traditional _import_ statements**. This enhances clarity and enables tools to infer dependencies during development with greater accuracy. For instance:\n```\nimport module java.base; \n//...\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = new Date();\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nHowever, we must be careful with ambiguous references. Let\u2019s see a sample code to demonstrate it:\n```\nimport module java.base;      // exports java.util, which includes java.util.Date\nimport module java.sql;       // exports java.sql, which also includes java.sql.Date\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = Date.valueOf(\"2025-06-15\");\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nWhen trying to compile this class, the following message will appear:\n```\nerror: reference to Date is ambiguous\n         Date d = Date.valueOf(\"2025-06-15\");\n         ^\n   both class java.sql.Date in java.sql and class java.util.Date in java.util match\n   error: reference to Date is ambiguousCopy\n```\n\nThe solution for this would be to add the import of the specific class that we want to use in this case:\n```\nimport module java.base;\nimport module java.sql;\n\nimport java.sql.Date;\n\npublic class Main {\n    public static void main(String[] args) {\n        Date d = Date.valueOf(\"2025-06-15\");\n        System.out.println(\"Resolved Date: \" + d);\n    }\n}Copy\n```\n\nFinally, this change also allows us to switch from star imports to module imports:\n```\n// These imports could be coalesced:\nimport javax.xml.*; \nimport javax.xml.parsers.*; \nimport javax.xml.stream.*;\nCopy\n```\n\nInstead, just use:\n```\nimport module java.xml;Copy\n```\n\nAlthough it is not recommended to abuse both import star and module imports, it does make the import and dependency definition more concise and less verbose.\n### 2.3. Compact Source Files (JEP 512) and Instance Main Methods[](https://www.baeldung.com/java-25-features#3-compact-source-files-jep-512-and-instance-main-methods)\nNow Java supports top-level instance _main_ methods and class-less compact files. That means now the following declaration is valid:\n```\nvoid main() {\n    System.out.println(\"Hello from Java 25!\");\n}Copy\n```\n\nJEP 512 builds on the simplified launcher introduced in Java 21. It allows us to write quick scripts or demos without class declarations. **These compact source files are ideal for teaching, scripting, and rapid prototyping, lowering the barrier to entry for new developers and reducing the learning curve**.\n### 2.4. Flexible Constructor Bodies (JEP 513 \u2013 Final)[](https://www.baeldung.com/java-25-features#4-flexible-constructor-bodies-jep-513--final)\nFlexible Constructor Bodies (JEP 513) enables multiple constructors to delegate to a common initialization body, making it as simple as that:\n```\nclass Person {\n    final int age;\n\n    Person(int age) {\n        this.age = age;\n    }\n}\n\nclass Employee extends Person {\n    final String name;\n\n    Employee(String name, int age) {\n        if (age < 18 || age > 67)\n            throw new IllegalArgumentException(\"Age must be between 18 and 67\");\n        super(age); // super() is no longer required as the first statement in Java 25\n        this.name = name;\n    }\n\n    public static void main(String[] args) {\n        var emp = new Employee(\"Alice\", 35);\n        System.out.println(\"Person age set: \" + emp.age);\n    }\n}\nCopy\n```\n\nBefore JEP 513, Java constructors were required to invoke _super(\u2026)_ or _this(\u2026)_ as the very first statement, which often forced us to duplicate validation or initialization logic, or push it into static helper methods. **With JEP 513, we can include code before the constructor invocation, allowing argument validation or shared setup to happen cleanly in one place, improving readability, fail-fast behavior, and object integrity without breaking Java\u2019s construction rules**.\n## 3. API Enhancements[](https://www.baeldung.com/java-25-features#api-enhancements)\nJava 25 also brings a set of improvements for the existing APIs, in addition to continuing work on new APIs that are still in preview, final, and early stages.\n### 3.1. Scoped Values (JEP 506 \u2013 Final)[](https://www.baeldung.com/java-25-features#1-scoped-values-jep-506--final)\nJEP 506 offers lightweight, immutable, thread-safe alternative to _ThreadLocal_. Those are designed to work in conjunction with Virtual Threads:\n```\nimport java.lang.ScopedValue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ScopedUserExample {\n    static final ScopedValue<String> USER = ScopedValue.newInstance();\n\n    public static void main(String[] args) {\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            executor.submit(() -> ScopedValue.where(USER, \"Alice\").run(() -> {\n                System.out.println(\"Thread: \" + Thread.currentThread());\n                System.out.println(\"User: \" + USER.get());\n            }));\n\n            executor.submit(() -> ScopedValue.where(USER, \"Bob\").run(() -> {\n                System.out.println(\"Thread: \" + Thread.currentThread());\n                System.out.println(\"User: \" + USER.get());\n            }));\n\n            // Optional delay to ensure output appears before main exits\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\nCopy\n```\n\nScoped Values are designed to pass context across call chains in a safe, performant, and immutable way. They work particularly well with virtual threads and structured concurrency, offering an efficient alternative to _ThreadLocal_ by avoiding memory leaks and synchronization overhead.\n**Note: When we use Scoped Value with Virtual Threads, the logic that accesses the scoped value must be wrapped inside the _ScopedValue.where(\u2026).run(\u2026)_ scope. Submitting a task to an executor within the scope is not enough. The task itself must be created inside the scope to retain the binding.**\n### 3.2. Structured Concurrency (JEP 505 \u2013 Fifth Preview)[](https://www.baeldung.com/java-25-features#2-structured-concurrency-jep-505--fifth-preview)\nJEP 505 aims to simplify concurrency by treating related threads as a single unit with proper lifecycle management. The fifth preview refines the API by replacing constructors and separate policy methods with a single static factory method: _StructuredTaskScope.open()_. This approach improves consistency and flexibility for defining custom join and error-handling behaviors. Next, we\u2019ll use the new syntax:\n```\nimport java.util.concurrent.StructuredTaskScope;\n\npublic class StructuredExample {\n    static String fetchUser() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return \"Alice\";\n    }\n\n    static String fetchOrder() {\n        try {\n            Thread.sleep(150);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return \"Order#42\";\n    }\n\n    public static void main(String[] args) throws Exception {\n        try (var scope = StructuredTaskScope.<String>open()) {\n            var userTask = scope.fork(() -> fetchUser());\n            var orderTask = scope.fork(() -> fetchOrder());\n\n            scope.join();\n\n            System.out.println(userTask.get() + \" - \" + orderTask.get());\n        }\n    }\n}\nCopy\n```\n\nStructured concurrency helps us manage multiple concurrent tasks that are logically correlated. It guarantees that child threads complete or are cancelled as a group, improving reliability and readability in multi-threaded applications.\n### 3.3. Stable Value API (JEP 502 \u2013 Preview)[](https://www.baeldung.com/java-25-features#3-stable-value-api-jep-502--preview)\nThe Stable Value API (JEP 502) extends the _Optional-_ like semantics to context-stable immutable values:\n```\nimport java.lang.StableValue;\n\npublic class StableExample {\n    public static void main(String[] args) {\n        // Create a new unset StableValue\n        var greeting = StableValue.<String>of();\n\n        String message = greeting.orElseSet(() -> \"Hello from StableValue!\");\n        System.out.println(message);\n    }\n}\nCopy\n```\n\nStable values offer an API for safely sharing immutable, context-stable values across threads or computations. They\u2019re handy in situations involving caching, lazy evaluation, or consistent reads within a stable scope, and integrate well with structured concurrency.\n### 3.4. PEM Encodings of Cryptographic Objects (JEP 470 \u2013 Preview)[](https://www.baeldung.com/java-25-features#4-pem-encodings-of-cryptographic-objects-jep-470--preview)\nJEP 470 adds support for reading and writing cryptographic keys and certificates in PEM format via standard APIs. The new API abstracts such operations, making them as simple as:\n```\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class PEMExample {\n    public static void main(String[] args) {\n      String pem = \"\"\"\n        -----BEGIN PUBLIC KEY-----\n        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgjDohS0RHP395oJxciVaeks9N\n        KNY5m9V1IkBBwYsMGyxskrW5sapgi9qlGSYOma9kkko1xlBs17qG8TTg38faxgGJ\n        sLT2BAmdVFwuWdRtzq6ONn2YPHYj5s5pqx6vU5baz58/STQXNIhn21QoPjXgQCnj\n        Pp0OxnacWeRSnAIOmQIDAQAB\n        -----END PUBLIC KEY-----\n        \"\"\";\n\n        try {\n            String base64 = pem.replaceAll(\"-----.*-----\", \"\").replaceAll(\"\\\\s\", \"\");\n            byte[] keyBytes = Base64.getDecoder().decode(base64);\n\n            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);\n            KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n            PublicKey key = factory.generatePublic(spec);\n\n            System.out.println(\"Loaded key: \" + key.getAlgorithm());\n        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n    }\n}\nCopy\n```\n\nNow we can utilize the Java Security API to handle PEM-encoded objects, such as X.509 certificates and RSA keys, directly, eliminating the need for third-party libraries or manual conversions. This improves interoperability with OpenSSL-based systems and streamlines secure communications.\n### 3.5. Vector API (JEP 508 \u2013 Tenth Incubator)[](https://www.baeldung.com/java-25-features#5-vector-api-jep-508--tenth-incubator)\nJEP 508 provides an API to express vector computations that reliably compile to optimal vector hardware instructions:\n```\nimport jdk.incubator.vector.*;\n\npublic class VectorExample {\n    public static void main(String[] args) {\n        float[] left = {1f, 2f, 3f, 4f};\n        float[] right = {5f, 6f, 7f, 8f};\n\n        FloatVector a = FloatVector.fromArray(FloatVector.SPECIES_128, left, 0);\n        FloatVector b = FloatVector.fromArray(FloatVector.SPECIES_128, right, 0);\n        FloatVector c = a.add(b);\n\n        float[] result = new float[FloatVector.SPECIES_128.length()];\n        c.intoArray(result, 0);\n\n        System.out.println(\"Vector result: \" + java.util.Arrays.toString(result));\n    }\n}Copy\n```\n\n**Requires:_\u2013enable-preview \u2013add-modules jdk.incubator.vector_**\nThe Vector API enables data-parallel computations that can be executed efficiently on modern central processing units (CPUs). It helps Java code achieve performance comparable to hand-tuned native code by utilizing SIMD instructions, and continues to evolve through incubator stages.\n### 3.6. Key Derivation Function API (JEP 510 \u2013 Final)[](https://www.baeldung.com/java-25-features#6-key-derivation-function-api-jep-510--final)\nJava 25 introduces a standard API for password-based key derivation functions, such as PBKDF2 and scrypt:\n```\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\npublic class KeyDerivationExample {\n    public static void main(String[] args) throws Exception {\n        char[] password = \"hunter2\".toCharArray();\n        byte[] salt = \"somesalt\".getBytes();\n        PBEKeySpec spec = new PBEKeySpec(password, salt, 65536, 256);\n\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        SecretKey key = factory.generateSecret(spec);\n\n        System.out.println(\"Derived key format: \" + key.getFormat());\n    }\n}\nCopy\n```\n\nJEP 510 standardizes access to widely used cryptographic primitives for deriving encryption keys from user passwords, reducing reliance on third-party libraries and enabling secure implementations out of the box.\n## 4. Other Changes[](https://www.baeldung.com/java-25-features#other-changes)\nJava 25 changes also include the removal of configurations, platform-based updates, and enhancements.\n### 4.1. Remove the 32-bit x86 Port (JEP 503 \u2013 Final)[](https://www.baeldung.com/java-25-features#1-remove-the-32-bit-x86-port-jep-503--final)\nJEP 503 removes the support for the legacy 32-bit x86 architecture from OpenJDK. This JEP eliminates maintenance overhead for a platform with dwindling relevance. The 64-bit x86 and ARM64 ports remain fully supported.\n### 4.2. JFR CPU-Time Profiling (JEP 509 \u2013 Experimental)[](https://www.baeldung.com/java-25-features#2-jfr-cpu-time-profiling-jep-509--experimental)\nJEP 509 adds CPU-time-based profiling support to Java Flight Recorder (JFR). This feature enables us to record and analyze the amount of CPU time spent in specific methods or threads, thereby improving performance diagnostics, particularly in multi-threaded and I/O-bound workloads. Use the new _JDK.CPULoad_ and related JFR events with custom recordings:\n```\njava\n  -XX:StartFlightRecording=filename=cpu-time.jfr,duration=10s,settings=profile\n  --enable-preview\n  MyApp>Copy\n```\n\nThen analyze the _CPU time.JFR_ file in JDK Mission Control or VisualVM to observe CPU usage per method and thread.\n### 4.3. Ahead-of-Time Command-Line Ergonomics (JEP 514 \u2013 Final)[](https://www.baeldung.com/java-25-features#3-ahead-of-time-command-line-ergonomics-jep-514--final)\nJEP 514 is part of Project Leyden and introduces new JVM command-line flags (_-XX:AOTCacheOutput= <file>_) that disable dynamic features (like class loading and reflection) to evaluate how well an application could perform in a constrained runtime environment. These flags help us identify problematic code paths that would hinder static image generation or future ahead-of-time (AOT) compilation.\nWhile Java 25 does not yet provide a built-in AOT compiler, this JEP lays the groundwork by enabling early experimentation. It supports the long-term goal of delivering static Java applications with predictable startup performance and low memory footprint.\n### 4.4. Ahead-of-Time Method Profiling (JEP 515 \u2013 Final)[](https://www.baeldung.com/java-25-features#4-ahead-of-time-method-profiling-jep-515--final)\nJEP 515 introduces method-level profiling that records which methods are called and how often, along with other execution characteristics. This data can be saved and reused to inform future optimizations, such as ahead-of-time (AOT) compilation. While Java 25 does not yet include an AOT compiler, this JEP lays critical groundwork for improving startup performance in future versions by enabling profile-guided optimizations.\n### 4.5. JFR Cooperative Sampling (JEP 518 \u2013 Final)[](https://www.baeldung.com/java-25-features#5-jfr-cooperative-sampling-jep-518--final)\nJEP 518 allows applications to suggest safe sampling points to Java Flight Recorder. Cooperative sampling reduces overhead by aligning sampling with application-defined safe points, improving accuracy while minimizing disruption to performance-sensitive code.\n### 4.6. Compact Object Headers (JEP 519 \u2013 Final)[](https://www.baeldung.com/java-25-features#6-compact-object-headers-jep-519--final)\nJEP 519 reduces object header size on 64-bit architectures. This change shrinks the memory footprint of Java objects by using compact layouts for synchronization and identity data in object headers. It particularly benefits large heaps and microservice environments.\n### 4.7. JFR Method Timing and Tracing (JEP 520 \u2013 Final)[](https://www.baeldung.com/java-25-features#7-jfr-method-timing-and-tracing-jep-520--final)\nJEP 520 improves observability by recording timing data for all method calls on a thread, not just sampled methods. This enables precise reconstruction of method call stacks and durations for time intervals, helping us analyze execution flow and concurrency behavior more thoroughly. It complements existing profiling features by offering richer, deterministic tracing data rather than probabilistic sampling.\n### 4.8. Generational Shenandoah (JEP 521 \u2013 Final)[](https://www.baeldung.com/java-25-features#8-generational-shenandoah-jep-521--final)\nJEP 521 adds generational support to the Shenandoah garbage collector. Generational GC improves throughput and pause time performance by optimizing young-generation collection separately from long-lived objects. It brings Shenandoah in line with collectors like G1 and ZGC in terms of efficiency.\n## 5. What Developers Need to Know[](https://www.baeldung.com/java-25-features#what-developers-need-to-know)\nAs we just saw, many features in Java 25 are still in preview or incubator stage. To compile and run the code using these features, we must enable them. We already did in preview code snippets, but it\u2019s worth understanding it better:\n  * _\u2013enable-preview_ : required for all preview features, otherwise compile errors will appear\n  * _\u2013add-modules_ _< name>_: required for incubating modules, such as the _jdk.incubator.vector_ we used earlier\n  * _\u2013release 25_ : recommended during compilation to target the Java 25 platform\n\n\n**Be aware that preview and incubator APIs may change or be removed in future version** s. We should avoid using them in production or stay up to date with the official JDK documentation and release notes to look out for bug fixes or problems. Having this in mind, to compile and run code with such features, we need:\n```\n# At compile time do\njavac --enable-preview --release 25 --add-modules jdk.incubator.vector MyClass.java\n\n# At runtime do\njava --enable-preview --add-modules jdk.incubator.vector MyAppCopy\n```\n\nThis way we hint the Java Virtual Machine (JVM) to allow the use of such features at compile and runtime.\n## 6. Conclusion[](https://www.baeldung.com/java-25-features#conclusion)\nJava 25 continues the platform\u2019s steady evolution toward modernization and efficiency. It refines many preview features, introduces new APIs, and improves performance at every level, from language syntax to runtime diagnostics and memory management.\nThis release also highlights Java\u2019s commitment to modern hardware, including profiling and additional features. Java 25 is the newer LTS release. It offers valuable advantages and new capabilities that make it worthwhile for us, as developers, to upgrade our applications, so that we can leverage the new features added since the last LTS version (Java 21). The complete list of changes in Java 25 is in the \n12 Comments \nOldest\nNewest\nView all comments\nView Comments \nLoad More Comments \n\n\nwpDiscuz\nInsert\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 16
      },
      "classification": "-",
      "action": " ",
      "index": 16,
      "updated": false
    }
  },
  {
    "rule": {
      "rule_title": "ScopedValue.orElse should not accept null arguments",
      "rule_idea": "In Java 25, the ScopedValue.orElse method no longer accepts null as its argument. This rule detects when null is passed to ScopedValue.orElse method calls, which will cause runtime errors in Java 25.",
      "code_examples": [
        {
          "non_compliant": "ScopedValue<String> scopedValue = ScopedValue.newInstance();\nString result = scopedValue.orElse(null); // This will fail in Java 25",
          "compliant": "ScopedValue<String> scopedValue = ScopedValue.newInstance();\nString result = scopedValue.orElse(\"default\"); // Provide a non-null default value"
        }
      ],
      "sources": [
        {
          "url": "https://www.infoworld.com/article/3846172/jdk-25-the-new-features-in-java-25.html",
          "source_text": "by [Paul Krill](https://www.infoworld.com/profile/paul-krill/)\nEditor at Large\nUpdated \n# JDK 25: The new features in Java 25\nnews\nSep 16, 202513 mins\n[Java](https://www.infoworld.com/java/)[Programming Languages](https://www.infoworld.com/programming-languages/)[Software Development](https://www.infoworld.com/software-development/)\n##  Long-Term Support release, with features ranging from structured concurrency and compact object headers to ahead-of-time method profiling and JFR CPU-time profiling on Linux, is now generally available. \nCredit: \nJava Development Kit (JDK) 25, a new Long-Term Support (LTS) release of standard Java, is now generally available. The release brings 18 features, five of which Oracle touts as assisting with AI development.\nJDK 25 comes on the heels of [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html), a six-month-support release that arrived March 18. As a Long-Term support release, JDK 25 will get at least eight years of [JDK 21](https://www.infoworld.com/article/2338097/jdk-21-the-new-features-in-java-21.html), which arrived in September 2023.\nJDK 25 can be downloaded from \nFive of these features aid in the development of AI applications, Oracle said. Primitive types in patterns, instanceof, and switch make integrating business logic with primitive types from AI easier, according to the company. Module import declarations offer easier integration of business logic with AI inference, libraries, or service calls, while the Vector API often is used in AI inference and compute scenarios. Structured concurrency fits in with AI because AI development often involves running multiple tasks in parallel. And scoped values enable sharing of immutable data within and across threads with lower space and time costs versus thread-local variables, Oracle said.\nWith [PEM](https://www.infoworld.com/article/3846172/%5C%22/en.wikipedia.org/wiki/Privacy-Enhanced_Mail%22%5C%22) format transport, and for decoding from the format back into objects. The Java platform has not had an easy-to-use API for decoding and encoding in the PEM format. A main goal of the feature is ease of use. Another goal is support for conversions between PEM text and cryptographic objects that have standard representations in the binary formats \n[planned for JDK 21 in 2023 but was dropped](https://www.infoworld.com/article/2338620/java-21-to-drop-generational-shenandoah-gc-feature.html) because the capability was deemed not ready at the time.\n[ahead-of-time class loading and linking](https://www.infoworld.com/article/3482187/ahead-of-time-class-loading-proposal-would-speed-java-startups.html) in JDK 24.\nA third preview of `instanceof` and `switch` to work with all primitive types. The intent is to help developers increase Java programming productivity by making Java more uniform and expressive. Originally proposed in [JDK 23](https://www.infoworld.com/article/2336682/jdk-23-the-new-features-in-java-23.html) and followed up in JDK 24, this would still be a preview language feature in JDK 25. Among goals are enabling data exploration by allowing type patterns for all types, whether primitive or reference, and providing easy-to-use constructs that eliminate the risk of losing information due to unsafe casts.\n[JDK 20](https://www.infoworld.com/article/2336904/jdk-20-whats-next-for-java.html), proposed for preview in [JDK 21](https://www.infoworld.com/article/2338097/jdk-21-the-new-features-in-java-21.html), and subsequently refined for [JDK 22](https://www.infoworld.com/article/2335077/jdk-22-the-new-features-in-java-22.html) through [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html). The feature will be finalized in JDK 25, with one change: the `ScopedValue.orElse` method no longer accepts `null` as its argument.\nThe [JDK 16](https://www.infoworld.com/article/2259413/jdk-16-the-new-features-in-java-16.html). Two notable implementation changes are featured in the JDK 25 implementation of the API. First, the implementation now links to native mathematical-function libraries via the [C++](https://www.infoworld.com/article/2338049/c-23-language-standard-declared-feature-complete.html) code inside the HotSpot JVM, thus improving maintainability. Second, addition, subtraction, division, multiplication, square root, and fused multiply/add operations on `Float16` values now are auto-vectorized on supporting x64 CPUs. Additionally, **`VectorShuffle `**now supports access to and from`MemorySegment`.\nThe \n[JDK 21](https://www.infoworld.com/article/2338097/jdk-21-the-new-features-in-java-21.html) through [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html), after being incubated in [JDK 19](https://www.infoworld.com/article/2334631/jdk-19-the-new-features-in-java-19.html) and `StructuredTaskScope` that waits for all subtasks to succeed or any subtask to fail.\n[JDK 22](https://www.infoworld.com/article/2335077/jdk-22-the-new-features-in-java-22.html) as \u201cstatements before super(\u2026)\u201d as well as in [JDK 23](https://www.infoworld.com/article/2336682/jdk-23-the-new-features-in-java-23.html) and [JDK 24](https://www.infoworld.com/article/3491404/jdk-24-the-new-features-in-java-24.html). The feature is intended to be finalized in JDK 25. In flexible constructor bodies, the body of a constructor allows statements to appear before an explicit constructor invocation such as `super (\u2026)` or `this (\u2026)`.\nSeparate from the `String`, by allowing the `String::hashCode` function to take advantage of a compiler optimization called constant folding. Developers who use strings as keys in a static unmodifiable `Map` should see significant performance boosts, according to a May 1 article on Oracle\u2019s \n## Related content\n### [Smoother Kubernetes sailing with AKS Automatic By Simon Bisson Sep 18, 2025 8 mins ](https://www.infoworld.com/article/4058764/smoother-kubernetes-sailing-with-aks-automatic.html) ### [Software developers aren\u2019t buying it By Nick Hodges Sep 17, 2025 5 mins ](https://www.infoworld.com/article/4058058/software-developers-arent-buying-it.html) ### [Rust tutorial: Get started with the Rust language By Serdar Yegulalp Sep 17, 2025 15 mins ](https://www.infoworld.com/article/2258463/rust-tutorial-get-started-with-the-rust-language.html) ### [Is AI the 4GL we\u2019ve been waiting for? By Matthew Tyson Sep 17, 2025 7 mins ](https://www.infoworld.com/article/4049946/is-ai-the-4gl-weve-been-waiting-for.html)\nby [ Paul Krill ](https://www.infoworld.com/profile/paul-krill/)\nEditor at Large\nPaul Krill is editor at large at InfoWorld. Paul has been covering computer technology as a news and feature reporter for more than 35 years, including 30 years at InfoWorld. He has specialized in coverage of software development tools and technologies since the 1990s, and he continues to lead InfoWorld\u2019s news coverage of software development platforms including Java and .NET and programming languages including JavaScript, TypeScript, PHP, Python, Ruby, Rust, and Go. Long trusted as a reporter who prioritizes accuracy, integrity, and the best interests of readers, Paul is sought out by technology companies and industry organizations who want to reach InfoWorld\u2019s audience of software developers and other information technology professionals. Paul has won a \u201cBest Technology News Coverage\u201d award from IDG. \n## More from this author\n  * [news San Francisco AI technology conference draws protests Sep 18, 2025 2 mins ](https://www.infoworld.com/article/4058978/san-francisco-ai-technology-conference-draws-protests.html)\n  * [news Visual Studio 2026 doubles down on AI-assisted coding Sep 16, 2025 2 mins ](https://www.infoworld.com/article/4058164/visual-studio-2026-doubles-down-on-ai-assisted-coding.html)\n  * [news Survey pinpoints Rust compiler pain points Sep 15, 2025 3 mins ](https://www.infoworld.com/article/4057215/survey-pinpoints-rust-compiler-pain-points.html)\n  * [news Kotlin 2.2.20 boosts WebAssembly support Sep 12, 2025 2 mins ](https://www.infoworld.com/article/4056077/kotlin-2-2-20-boosts-webassembly-support.html)\n  * [news VS Code 1.104 emphasizes AI model selection, agent security Sep 11, 2025 3 mins ](https://www.infoworld.com/article/4056026/vs-code-1-104-emphasizes-ai-model-selection-agent-security.html)\n  * [news JFrog announces \u2018agentic repo\u2019 for AI-driven development Sep 10, 2025 2 mins ](https://www.infoworld.com/article/4055080/jfrog-announces-agentic-repo-for-ai-driven-development.html)\n  * [news .NET 10 moves to release candidate stage Sep 10, 2025 3 mins ](https://www.infoworld.com/article/4054199/net-10-moves-to-release-candidate-stage.html)\n  * [news JDK 26: The new features in Java 26 Sep 9, 2025 3 mins ](https://www.infoworld.com/article/4050993/jdk-26-the-new-features-in-java-26.html)\n\n\n## Show me more\nPopularArticlesVideos\n[ feature Designing AI-ready architectures in compliance-heavy environments By Rama Devi Drakshpalli Sep 18, 202512 mins Artificial IntelligenceData GovernanceData and Information Security ](https://www.infoworld.com/article/4058747/designing-ai-ready-architectures-in-compliance-heavy-environments.html)\n[ news MongoDB adds vector search to self-managed editions to power generative AI apps By Anirban Ghoshal Sep 17, 20253 mins DatabasesNoSQL Databases ](https://www.infoworld.com/article/4058564/mongodb-adds-vector-search-to-self-managed-editions-to-power-generative-ai-apps.html)\n[ feature The rise of AI-ready private clouds By Mark Cusack Sep 17, 202511 mins ContainersKubernetesMachine Learning ](https://www.infoworld.com/article/4057189/the-rise-of-ai-ready-private-clouds.html)\n[ video Easier Chrome browser automation with PyDoll Sep 16, 20254 mins Python ](https://www.infoworld.com/video/4057906/easier-chrome-browser-automation-with-pydoll.html)\n[ video How to use Rust workspaces to speed up compile times Sep 9, 20253 mins Python ](https://www.infoworld.com/video/4054034/how-to-use-rust-workspaces-to-speed-up-compile-times.html)\n[ video Getting encryption wrong (and getting it right, too) Sep 2, 20257 mins Python ](https://www.infoworld.com/video/4049684/getting-encryption-wrong-and-getting-it-right-too.html)\nSponsored Links\n"
        }
      ],
      "related_rules": []
    },
    "metadata": {
      "id": {
        "id": 17
      },
      "classification": "-",
      "action": " ",
      "index": 17,
      "updated": false
    }
  }
]